<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

        <title>Chapter 2 - My Docs</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../css/prettify-1.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">My Docs</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../Features/">Features</a>
                    </li>
                
                
                
                    <li >
                        <a href="../chapter1/">Chapter1</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">Chapter 2</a>
                    </li>
                
                
                
                    <li >
                        <a href="../chapter_3/">Chapter 3</a>
                    </li>
                
                
                </ul>
            

            
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                
                <li >
                    <a rel="next" href="../chapter1/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../chapter_3/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                
            </ul>
            
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<p>Tracking instances and <strong>new</strong></p>
<p>The <strong>init</strong> method of python objects is often mistakenly referred to as the
constructor. This idea is usually close enough for rock and roll, but it is
not technically true. When the <strong>init</strong> method is called, the object already
exists. This is evident by the fact that self is actually an argument to
the call to <strong>init</strong>:</p>
<pre class="prettyprint well"><code>...
def __init__(self, arguments):
...
</code></pre>
<p>When an object is instantiated, there is a method that is called before <strong>init</strong>.
This method is <strong>new</strong>. This method is not normally needed for basic things like
assigning attributes to the instance - such things should be done in <strong>init</strong>, 
not <strong>new</strong>. The implicit call to <strong>new</strong> - the one that has been called every
time you have instantiated an object that you may have not known about - effectively 
does something similar to the following:</p>
<pre class="prettyprint well"><code>class Base(object):

    def __new__(cls, *args, **kwargs):
        return super(Base, cls).__new__(cls, *args, **kwargs)
</code></pre>
<p>The return value of the method actually returns the newly created object.          <br />
So what <em>would</em> we need to use this for? One of the use cases is tracking
instances. When an instance is created, we can give it a number and associate
this number with the instance:</p>
<pre class="prettyprint well"><code>class Base(object):

    instance_count = 0

    def __new__(cls, *args, **kwargs):
        instance = super(Base, cls).__new__(cls, *args, **kwargs)
        instance_number = instance.instance_number = cls.instance_count
        cls.instance_tracker[instance_number] = instance
        cls.instance_count += 1
        return instance

&gt;&gt;&gt; b = base.Base()
&gt;&gt;&gt; b.instance_number
&gt;&gt;&gt; 0
&gt;&gt;&gt; base.Base.instance_tracker[0]
&gt;&gt;&gt; &lt;base.Base object at 0x01D35830&gt;
</code></pre>
<p>We can also use a property attribute to tie together the class name of the
object with its number to produce a name for the object. A property is 
effectively a calculated attribute. It takes up to three arguments - a method 
to be called when getting, setting, or deleting the attribute in question:</p>
<pre class="prettyprint well"><code>class Base(object):

    def _get_name(self):
        return type(self).__name__ + str(self.instance_number)
    instance_name = property(_get_name)
    ...
</code></pre>
<p>Base objects will now have a name attribute that provides the class name
along with the instance number:</p>
<pre class="prettyprint well"><code>&gt;&gt;&gt; b = base.Base()
&gt;&gt;&gt; b.instance_name
&gt;&gt;&gt; 'Base0'
</code></pre>
<p>This is a string representation that is effectively unique to the object
in question. With a dictionary we can then map this unique name to the
object itself, and we can automatically populate this dictionary whenever
an object is instantiated:</p>
<pre class="prettyprint well"><code>Component_Resolve = {}

class Base(object):

    instance_count = 0

    defaults = {"memory_size" : 4096, "network_packet_size" : 8192}

    def _get_name(self):
        return type(self).__name__ + str(self.instance_number)
    instance_name = property(_get_name)

    def __new__(cls, *args, **kwargs):
        instance = super(Base, cls).__new__(cls, *args, **kwargs)
        instance_number = instance.instance_number = cls.instance_count
        cls.instance_tracker[instance_number] = instance
        cls.instance_count += 1
        return instance

    def __init__(self, **kwargs):
        options = self.defaults.copy()
        options.update(kwargs)
        self.attribute_setter(**options)
        Component_Resolve[self.instance_name] = self

&gt;&gt;&gt; base.Base() # instantiate but did not assign the result to a variable
&gt;&gt;&gt; b = Component_Resolve["Base0"]
&gt;&gt;&gt; b # got the created object anyways
&gt;&gt;&gt; &lt;base.Base object at 0x01D35830&gt;
</code></pre>
<p>Note how our defaults has included a memory size attribute that has not been used
yet. Python has a module called mmap, which supports memory mapping files that
reside on disk into memory. You can also map anonymous regions of memory which
do not have a relation to any file on disk. Doing so will yield an empty storage 
space that you can store arbitrary data in. We can setup our objects to have their
own little chunk of memory like so:</p>
<pre class="prettyprint well"><code>Component_Memory = {}

class Base(object):
    ...
    def __init__(self, **kwargs):
        ...
        Component_Memory[self.instance_name] = mmap.mmap(-1, self.memory_size)
</code></pre>
<p>The -1 supplied as the first argument indicates that we want an anonymous region
of memory that is not associated with a file on disk. Each base object will now
have 4kb of memory that any other object can write to. We can provide methods
for reading/writing from/to this memory:</p>
<pre class="prettyprint well"><code>class Base(object):
    ...
    def send_to(self, component_name, message):
        Component_Memory[component_name].write(message+"delimiter")

    def read_messages(self):
        memory = Component_Memory[self.instance_name]
        memory.seek(0) # like a file, reads/writes changes the seek position
        data = memory.read(self.memory_size) # read the entire memory segment
        memory.seek(0)
        if data.count("delimiter"): # check to see if we got messages
            size = len(data) # read doesn't necessarily return memory_size bytes
            messages = data.split("delimiter")
            memory.write("\x00"*size) # make room for more messages
            memory.seek(0) # reset seek position
        else: # no messages received
            messages = [] 
        return messages

&gt;&gt;&gt; b = base.Base()
&gt;&gt;&gt; b.data = []
&gt;&gt;&gt; c = base.Base()
&gt;&gt;&gt; c.data = "this is a test message!"
&gt;&gt;&gt; c.send_to("Base0", c.data)
&gt;&gt;&gt; for message in b.read_messages():
&gt;&gt;&gt;     b.data.append(message)
&gt;&gt;&gt; ...
&gt;&gt;&gt; b.data
&gt;&gt;&gt; ["this is a test message!"]
</code></pre>
<p>While the test message isn't that impressive or interesting, the messaging 
scheme here is a matter of good form - while we could read c's data directly
and put it into b's data manually, it is best to have each object be responsible
for manipulating it's own data members. Good form often yields other benefits,
especially regarding manageability of code.</p>
</div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        

        <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/prettify-1.0.min.js"></script>
        <script src="../js/base.js"></script>
        
    </body>
</html>