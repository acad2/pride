<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

        <title>Chapter1 - My Docs</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../css/prettify-1.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">My Docs</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../Features/">Features</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">Chapter1</a>
                    </li>
                
                
                
                    <li >
                        <a href="../chapter_2/">Chapter 2</a>
                    </li>
                
                
                
                    <li >
                        <a href="../chapter_3/">Chapter 3</a>
                    </li>
                
                
                </ul>
            

            
            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                
                <li >
                    <a rel="next" href="../Features/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../chapter_2/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                
            </ul>
            
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<p>Metaprogramming</p>
<p>The word root meta applies the word that follows to itself. Programming is the art
of writing code for computers. It follows then, that metaprogramming is the art
of writing code that writes code. This may sound somewhat challenging, but in reality
it sounds more intimidating then it really is. </p>
<p>For example, a standard CPython class definition would look something like:</p>
<pre class="prettyprint well"><code>class Base(object):

    def __init__(self, memory_size=8192, network_chunk_size=4096):
        self.memory_size = memory_size
        self.network_chunk_size = network_chunk_size

&gt;&gt;&gt; base_object = Base()
&gt;&gt;&gt; base_object.memory_size
&gt;&gt;&gt; 8192
&gt;&gt;&gt; base_object.network_chunk__size
&gt;&gt;&gt; 4096
</code></pre>
<p>There is actually quite a bit of repetition there. Did you notice that the terms
memory_size and network_chunk_size are used three times each? Repetition is 
where computers excel, so we should try to delegate repetitive jobs to the computer. 
We can rewrite this in a more succinct fashion and avoid repeating ourselves:</p>
<pre class="prettyprint well"><code>base_defaults = {"memory_size" : 8192,
                 "network_chunk_size" : 4096}

class Base(object):

    def __init__(self, **kwargs):
        for attribute, value in kwargs.items():
            setattr(self, attribute, value)

&gt;&gt;&gt; base_object = Base(**base_defaults)
&gt;&gt;&gt; base_object.memory_size
&gt;&gt;&gt; 8192
&gt;&gt;&gt; base_object.network_chunk_size
&gt;&gt;&gt; 4096
</code></pre>
<p>So we avoided, repeating ourselves, which is nice, but are there any other benefits
to doing things this way? Suppose we wanted to rename network_chunk_size to 
network_packet_size. In the first definition, we would have to change three
separate things, while in the second, we would only have to change one. This might
seem like only a minor convenience. However, the more things that need to be changed
the higher the probability that something will go wrong. With only a single class
definition the benefits are relatively small, but when our projects start to grow,
this will save a significant amount of time and headaches. </p>
<p>This also enables our base object to accept arbitrary attributes simply be specifying
them as keyword arguments in the initialization call.</p>
<pre class="prettyprint well"><code>&gt;&gt;&gt; base_object = Base(testing=True)
&gt;&gt;&gt; base_object.testing
&gt;&gt;&gt; True
</code></pre>
<p>There is also another perk that might not be so immediately obvious. What if you wanted
to modify the default attributes/values that new instances are created with at runtime? 
In the first case, that would prove to be an ugly, relatively challenging mess. With our 
defaults dictionary it is a simple matter of changing the value and watching the results 
reflected in new instances.</p>
<p>We can actually take our defaults dictionary one step further. Previously we manually
supplied the dictionary to the call to instantiate the base object. It would be nice to
not have to do so. Python classes are themselves objects, which can have attributes. We
can attach our defaults dictionary to the class itself:</p>
<pre class="prettyprint well"><code>class Base(object):

    defaults = base_defaults

    def __init__(self, **kwargs):
        options = self.defaults.copy()
        options.update(kwargs)
        self.attribute_setter(**options)

    def attribute_setter(self, **kwargs)
        for attribute, value in kwargs.items():
            setattr(self, attribute, value)
</code></pre>
<p>Note that because dictionaries are mutable datatypes, we make a copy of it so 
that when we update it with the keyword arguments supplied to the instance we
do not change the class defaults permanently. We also moved the attribute 
setting functionality outside of <strong>init</strong> and into it's own method. It is a
wise investment to make things modular and therefore reusable. </p>
<p>So now we know how to programmatically define attributes. It is also possible
to programmatically define classes in CPython. The built in type "type" is
actually what creates classes behind the scenes. The following produce the 
same results:</p>
<pre class="prettyprint well"><code>class Attribute(Base):

    defaults = defaults.Attribute

    def __init__(self, **kwargs):
        super(Base, self).__init__(**kwargs)

Attribute = type("Attribute", (Base, ), {"defaults" : defaults.Attribute})
</code></pre>
<p>The arguments supplied to type are the new class name, a tuple containing the
bases that the class inherits from, and a dictionary of attributes that will
become the class attributes. Assuming we have defined our Attribute class,
let's programmatically define some subclasses in the following example:</p>
<pre class="prettyprint well"><code># an rpg video game themed example
attributes = ("Strength", "Endurance", "Dexterity", "Agility", "Intelligence", \
              "Focus", "Wisdom", "Wits", "Cognition")

for attribute in attributes:
    new_class = type(attribute, (Attribute, ), {})
&gt;&gt;&gt; Wits
&gt;&gt;&gt; &lt;class 'base.Wits'&gt;
</code></pre>
<p>We have just defined 9 new classes in 5 lines of code. It is not simply
convenient to have the computer write for you, the probability that at least
a single typo would have been made when manually writing out 9 different classes
is relatively high, even if you're a good typist. </p>
</div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        

        <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/prettify-1.0.min.js"></script>
        <script src="../js/base.js"></script>
        
    </body>
</html>