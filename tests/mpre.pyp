ccopy_reg
_reconstructor
p1
(cmpre.package
Package
p2
c__builtin__
object
p3
NtRp4
(dp5
S'files'
p6
(dp7
Vtests
p8
(lp9
VC:\u005cusers\u005c_\u005cpythonbs\u005cmpre\u005ctests\u005chashdicttest.py
p10
aVC:\u005cusers\u005c_\u005cpythonbs\u005cmpre\u005ctests\u005cinstalltest.py
p11
aVC:\u005cusers\u005c_\u005cpythonbs\u005cmpre\u005ctests\u005clru_test.py
p12
aVC:\u005cusers\u005c_\u005cpythonbs\u005cmpre\u005ctests\u005cnetwork2.py
p13
asVmpre
p14
(lp15
(Vbase.py
S'#   mpf.base - root inheritance objects, many framework features are defined here\n#\n#    Copyright (C) 2014  Ella Rose\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport mmap\nimport inspect\nimport sys\nimport argparse\nimport traceback\nimport functools\nimport heapq\nimport ast\nimport types\nimport importlib\nfrom copy import copy\n\nimport mpre\nimport defaults\nimport utilities\ntimer_function = utilities.timer_function\n\nComponent_Memory = mpre.Component_Memory\nComponent_Resolve = mpre.Component_Resolve\nParallel_Instructions = mpre.Parallel_Instructions\nParents = mpre.Parents\nReferences_To = mpre.References_To\n\nfrom threading import Lock\n\nmemlock = Lock()\n\nclass Docstring(object):\n    \n    def __init__(self):\n        super(Docstring, self).__init__()\n\n    def __get__(self, instance, _class):\n        _object = instance if instance else _class\n        return utilities.documentation(_object)\n        \n        \nclass Documented(type):\n    \n    def __new__(cls, name, bases, attributes):\n        Documented.make_docstring(attributes)\n        return super(Documented, cls).__new__(cls, name, bases, attributes)\n        \n    @staticmethod\n    def make_docstring(attributes):\n        attributes["__doc"] = attributes.get("__doc__", "No docstring found")\n        attributes["__doc__"] = Docstring()\n        \n        \nclass Runtime_Decorator(object):\n    """provides the ability to call a function with a decorator specified via\n    keyword argument.\n\n    example: my_function(my_argument1, decorator="decoratorlibary.Tracer")"""\n    __metaclass__ = Documented\n    \n    def __init__(self, function):\n        self.function = function\n        functools.update_wrapper(self, function)\n        self.handler_map = {"monkey_patch" : self._handle_monkey_patch,\n                            "decorator" : self._handle_decorator,\n                            "decorators" : self._handle_decorators}\n            \n    def __call__(self, *args, **kwargs):\n        check_for = kwargs.pop\n        modifiers = ("monkey_patch", "decorator", "decorators")\n        \n        for modifier in modifiers:\n            found = check_for(modifier, None)\n            if found:\n                call = self.handler_map[modifier](found)\n                break\n        else:\n            call = self.function\n        return call(*args, **kwargs)  \n            \n    def _handle_context_manager(self, args, kwargs):\n        module_name, context_manager_name = self._resolve_string(kwargs.pop("context_manager"))\n        module = self._get_module(module_name)\n        context_manager = getattr(module, context_manager_name)\n        with context_manager():\n            result = self.function(*args, **kwargs)\n        return result\n\n    def _handle_monkey_patch(self, patch_info):\n        module_name, patch_name = self._resolve_string(patch_info)\n        module = self._get_module(module_name)\n        monkey_patch = getattr(module, patch_name)\n        try:\n            result = functools.partial(monkey_patch, self.function.im_self)\n        except AttributeError: # function has no attribute im_self (not a method)\n            result = monkey_patch\n        return result\n\n    def _handle_decorator(self, decorator_type):\n        module_name, decorator_name = self._resolve_string(decorator_type)\n        decorator = self._get_decorator(decorator_name, module_name)\n        return decorator(self.function)\n\n    def _handle_decorators(self, decorator_names):\n        decorators = []\n        for item in decorator_names:\n            module_name, decorator_name = self._resolve_string(item)\n            decorator = self._get_decorator(decorator_name, module_name)\n            decorators.append(decorator)\n\n        wrapped_function = self.function\n        for item in reversed(decorators):\n            wrapped_function = item(wrapped_function)\n        return wrapped_function\n\n    def _resolve_string(self, string):\n        try: # attempt to split the string into a module and attribute\n            module_name, decorator_name = string.split(".")\n        except ValueError: # there was no ".", it\'s just a single attribute\n            module_name = "__main__"\n            decorator_name = string\n        finally:\n            return module_name, decorator_name\n\n    def _get_module(self, module_name):\n        try: # attempt to load the module if it exists already\n            module = sys.modules[module_name]\n        except KeyError: # import it if it doesn\'t\n            module = __import__(module_name)\n        finally:\n            return module\n\n    def _get_decorator(self, decorator_name, module_name):\n        module = self._get_module(module_name)\n        return getattr(module, decorator_name)\n\n\nclass Parser(object):\n    sys_argv_backup = copy(sys.argv)\n    __metaclass__ = Documented\n    \n    def __init__(self, parser, modifiers, exit_on_help, name):\n        super(Parser, self).__init__()\n        self.parser = parser\n        self.modifiers = modifiers\n        self.exit_on_help = exit_on_help\n        self.name = name\n\n    def get_arguments(self, argument_info):\n        arguments = {}\n        argument_names = argument_info.keys()\n        switch = {"short" : "-",\n                  "long" : "--",\n                  "positional" : ""}\n\n        default_modifiers = {"types" : ("long", )}\n        self_modifiers = self.modifiers\n        for name in argument_names:\n            modifiers = self_modifiers.get(name, default_modifiers)\n            if modifiers == "ignore":\n                continue\n            info = {}\n            for keyword_argument, value in modifiers.items():\n                info[keyword_argument] = value\n\n            temporary = {}\n            for arg_type in info.pop("types"):\n                if arg_type != "positional":\n                    temporary["dest"] = name\n\n                default_value = argument_info[name]\n                temporary["default"] = default_value\n                value_type = type(default_value)\n                if value_type == bool:\n                    value_type = ast.literal_eval\n                temporary["type"] = value_type\n\n                for key, value in temporary.items():\n                    info.setdefault(key, value)\n\n                arg_name = switch[arg_type] + name\n                arguments[arg_name] = info\n\n        parser = self.parser\n        exit_on_help = self.exit_on_help\n\n        for argument_name, options in arguments.items():\n            parser.add_argument(argument_name, **options)\n\n        new_argv = copy(Parser.sys_argv_backup)\n        sys.argv = new_argv\n\n        try:\n            arguments, unused = parser.parse_known_args()\n        except SystemExit:\n            if exit_on_help:\n                raise\n            try:\n                new_argv.pop(new_argv.index("-h"))\n            except ValueError:\n                new_argv.pop(new_argv.index("--help"))\n            arguments, unused = parser.parse_known_args()\n\n        if unused:\n          #  new_argv = copy(Parser.sys_argv_backup)\n            for unused_name in unused:\n                index = new_argv.index(unused_name)\n                new_argv.pop(index)\n\n                if "-" in unused_name: # pop whatever the value for the positional arg was too\n                    try:\n                        word = new_argv.pop(index)\n                    except IndexError: # no argument supplied to positional arg\n                        pass\n                    else:\n                        try:\n                            unused.remove(word)\n                        except ValueError:\n                            pass\n\n            arguments, unused = parser.parse_known_args()\n            sys.argv = copy(Parser.sys_argv_backup)\n        return arguments\n\n    def get_options(self, argument_info):\n        namespace = self.get_arguments(argument_info)\n        options = dict((key, getattr(namespace, key)) for key in namespace.__dict__.keys())\n        return options\n\n        \nclass Metaclass(Documented):\n    """Includes class.defaults attribute/values in docstrings.\\nApplies the Runtime_Decorator to class methods.\\nAdds instance trackers to classes."""\n    \n    #__metaclass__ = Documented # this actually works\n    parser = argparse.ArgumentParser()\n    command_parser = parser.add_subparsers(help="filename")\n    run_parser = command_parser.add_parser("run", help="execute the specified script")\n    profile_parser = command_parser.add_parser("profile", help="profile the specified script")\n\n    enable_runtime_decoration = True\n\n    def __new__(cls, name, bases, attributes):\n        new_class = super(Metaclass, cls).__new__(cls, name, bases, attributes)\n        new_class.instance_tracker = {}\n        new_class.instance_count = 0\n        # parser\n        exit_on_help = attributes.get("exit_on_help", True)\n\n        base_class = bases[0]\n        modifiers = getattr(base_class, "parser_modifiers", {}).copy()\n\n        parser_ignore = set()\n        new_parser_ignore = attributes.get("parser_ignore", tuple())\n        old_parser_ignore = getattr(base_class, "parser_ignore", tuple())\n        for ignore in new_parser_ignore + old_parser_ignore:\n            parser_ignore.add(ignore)\n        new_class.parser_ignore = tuple(parser_ignore)\n        for attribute in parser_ignore:\n            modifiers[attribute] = "ignore"\n\n        new_modifiers = attributes.get("parser_modifiers", {})\n        modifiers.update(new_modifiers)\n        Metaclass.make_parser(new_class, name, modifiers, exit_on_help)\n\n        if Metaclass.enable_runtime_decoration:\n            Metaclass.decorate(cls, new_class, attributes)\n        return new_class\n\n    @staticmethod\n    def make_parser(new_class, name, modifiers, exit_on_help):\n        parser = Metaclass.command_parser.add_parser(name)\n        new_class.parser = Parser(parser, modifiers, exit_on_help, name)\n\n    @staticmethod\n    def decorate(cls, new_class, attributes):\n        for key, value in new_class.__dict__.items():\n            if key[0] != "_" and callable(value):\n                bound_method = types.MethodType(Runtime_Decorator(value), \n                                                None, \n                                                new_class)\n                setattr(new_class, key, bound_method)\n        return new_class\n\n\nclass Instruction(object):\n    \n    def _get_execute_at(self):\n        return self.created_at + self.priority\n    execute_at = property(_get_execute_at)\n    log_processor_time = False\n\n    def _get_call(self):\n        return self.method, self.args, self.kwargs\n    call = property(_get_call)\n    \n    def __init__(self, component_name, method, *args, **kwargs):\n        super(Instruction, self).__init__()\n        self.component_name = component_name\n        self.method = method\n        self.args = args\n        self.kwargs = kwargs\n        self.priority = 0.0\n\n    def execute(self):\n        self.created_at = timer_function()\n        heapq.heappush(mpre.Instructions, (self.execute_at, self))\n            \n    def __str__(self):\n        args = self.args\n        kwargs = self.kwargs\n        number_of_formats = len(args)\n        arg_string = ", ".join("{0}".format(args[index]) for index in xrange(number_of_formats))\n        kwarg_string = ", ".join("{0}={1}".format(attr, value) for attr, value in kwargs.items())\n        format_arguments = (self.component_name, self.method)#, arg_string, kwarg_string)\n        return "Instruction {0}.{1}".format(*format_arguments)\n\n\nclass Alert(object):\n\n    log_level = 0\n    print_level = 0\n    log = open("Alerts.log", "w+")\n    level_map = {0 : "Error ",\n                \'v\' : "notification ",\n                \'vv\' : "verbose notification ",\n                \'vvv\' : "very verbose notification ",\n                \'vvvv\' : "extremely verbose notification "}\n\n                \nclass Base(object):\n    """A base object to inherit from. An object that inherits from base\n    can have arbitrary attributes set upon object instantiation by specifying\n    them as keyword arguments. An object that inherits from base will also\n    be able to create/hold arbitrary python objects by specifying them as\n    arguments to create. Classes that inherit from base should specify a class.defaults \n    dictionary that will automatically include the specified (attribute, value) pairs on \n    all new instances."""\n    __metaclass__ = Metaclass\n    \n    # A command line argument parser is generated automatically for\n    # every Base class based upon the attributes contained in the\n    # class defaults dictionary. Specific attributes can be modified\n    # or ignored by specifying them here.\n    parser_modifiers = {}\n    parser_ignore = ("network_packet_size", "memory_size")\n    \n    # public methods are methods that are available for direct use\n    # by external objects without requiring use of Instructions or\n    # message sending. Public methods are typically short and vital\n    # to the operation of the class that offers them \n    # i.e. Asynchronous_Network.buffer_data and add are public methods\n    public_methods = tuple()\n    \n    # the default attributes an instance will initialize with.\n    # storing them here and using the attribute_setter method\n    # makes them modifiable at runtime and eliminates the need\n    # to type out the usual self.attribute = value statements\n    defaults = defaults.Base\n    \n    def _get_parent(self):\n        return Parents[self]\n    parent = property(_get_parent)\n    \n    def __init__(self, **kwargs):\n        super(Base, self).__init__()\n        self._return_to = {}\n        \n        # register name + number\n        cls = type(self)\n        \n        instance_number = self.instance_number = cls.instance_count\n        cls.instance_tracker[instance_number] = self\n        cls.instance_count += 1\n        \n        ending = str(instance_number) if instance_number else \'\'\n        name = self.instance_name = cls.__name__ + ending\n        Component_Resolve[name] = self\n        \n        # mutable datatypes (i.e. containers) should not be used inside the\n        # defaults dictionary and should be set in the call to __init__\n        self.objects = {}\n\n        # instance attributes are assigned via kwargs\n        attributes = self.defaults.copy()\n        attributes.update(kwargs)\n        if kwargs.get("parse_args"):\n            attributes.update(self.parser.get_options(attributes))\n                \n        self.attribute_setter(**attributes)\n               \n        if self.memory_size:\n            memory = mmap.mmap(-1, self.memory_size)\n            Component_Memory[name] = memory, []\n\n    def attribute_setter(self, **kwargs):\n        """usage: object.attribute_setter(attr1=value1, attr2=value2).\n        called implicitly in __init__ for any object that inherits from Base."""\n        [setattr(self, attr, val) for attr, val in kwargs.items()]\n\n    def create(self, instance_type, *args, **kwargs):\n        """usage: object.create("module_name.object_name", args, kwargs)\n\n        The specified python object will be instantiated with the given arguments\n        and placed inside object.objects under the created objects class name via\n        the add method"""\n        if not isinstance(instance_type, type):\n            instance_type = self._resolve_string(instance_type)\n                    \n        # instantiate the new object from a class object\n        instance = instance_type(*args, **kwargs)\n\n        self.add(instance)\n        Parents[instance] = self.instance_name\n        return instance\n\n    def delete(self):\n        """usage: object.delete() or object.delete(child). thoroughly untested."""\n        assert not self.deleted\n        self.deleted = True\n        \n        name = self.instance_name\n                \n        del self.instance_tracker[self.instance_number]\n       \n        # changing a list while iterating through it produces non intuitive results\n        # copies have to be made\n        for child_type, children in self.objects.items():\n            children_names = [child.instance_name for child in children]\n            for _name in children_names:\n                Component_Resolve[_name].delete()\n                \n        print "deleting references to", self\n        names = [instance_name for instance_name in References_To[self]]\n        for instance_name in names:\n            instance = Component_Resolve[instance_name]\n            instance.remove(self)\n\n        del Component_Resolve[name]\n        if self.memory_size:\n            del Component_Memory[name]      \n       # print "\\nFinished deleting {}".format(self.instance_name)\n\n    def remove(self, instance):\n        """Usage: object.remove(instance)\n        \n        Removes an instance from self.objects"""\n        self.objects[instance.__class__.__name__].remove(instance)\n        References_To[instance].remove(self.instance_name)\n                \n    def add(self, instance):\n        """usage: object.add(instance)\n\n        adds an instance to the instances\' class name entry in parent.objects.\n        """        \n        references = References_To.get(instance, set())\n        \n        objects = self.objects\n        instance_class = instance.__class__.__name__\n        siblings = objects.get(instance_class, [])  \n                        \n        if instance not in siblings:\n            siblings.append(instance)\n            objects[instance_class] = siblings\n            references.add(self.instance_name)\n            References_To[instance] = references            \n                \n    def alert(self, message="Unspecified alert message",\n                    format_args=tuple(),\n                    level=0,\n                    callback=None, callback_instruction=None):\n        """usage: base.alert(message, format_args, level, callback, callback_instruction)\n\n        Create an alert. Depending on the level given, the alert may be printed\n        for immediate attention and/or logged quietly for later viewing.\n\n        -message is a string that will be logged and/or displayed\n        -format_args are any string formatting args for message.format()\n        -level is a small integer indicating the severity of the alert.\n        -callback is an optional tuple of (function, args, kwargs) to be called when\n        the alert is triggered\n        -callback_instruction is an optional Instruction to be posted when the alert is triggered.\n\n        alert severity is relative to the Alert.log_level and Alert.print_level;\n        a lower number indicates a less verbose notification, while 0 indicates\n        an error or exception and will never be suppressed."""\n\n        if self.verbosity >= level:\n            message = self.instance_name + ": " + message.format(*format_args)\n            if not Alert.print_level or level <= Alert.print_level:\n                sys.stdout.write(message + "\\n")\n            if level <= Alert.log_level:\n                severity = Alert.level_map.get(level, str(level))\n                Alert.log.write(severity + message + "\\n")\n            if callback_instruction:\n                callback_instruction.execute()\n            if callback:\n                function, args, kwargs = callback\n                return function(*args, **kwargs)\n                        \n    def public_method(self, component_name, method_name, *args, **kwargs):\n        """usage: base.public_method(component_name, method_name, *args, **kwargs) =>\n                  component.method(*args, **kwargs)\n                  \n           Used to call the method of an external object directly without using \n           instructions or message sending/reading. Public methods are designated in\n           the public_methods field of a class object. Attempting to call a\n           public_method on an object that does not specify the method as public\n           will result in a ValueError. This call is not scheduled by the processor\n           and happens immediately. The return value from the external method is \n           returned by this call."""\n        component = Component_Resolve[component_name]\n        if method_name in component.public_methods:\n            return getattr(component, method_name)(*args, **kwargs)\n        else:\n            raise ValueError\n    \n    def rpc(self, component_name, message,\n            _response_to="None"):\n        """Usage: component.send(component_name, message)\n        \n        Writes the supplied message to the memory owned by component_name.\n        Internally, an index to the end of the message is stored for later retrieval.\n        \n            - component_name is a base_object.instance_name\n            - message can be bytes or a string"""\n        #if memlock.locked():\n        #    print "concurrency error !"\n       #     raise SystemExit\n      #  memlock.acquire()\n        memory, pointers = Component_Memory[component_name]\n        Parallel_Instructions.append(component_name)\n        \n        reaction = \'\'\n        if message[:6] == "return":\n            flag, reaction, message = message.split(" ", 2)\n            \n        id, packet = self._make_packet(_response_to, message)\n        if reaction:\n            self._return_to[id] = reaction\n        \n        memory.write(packet)\n        pointers.append((self.instance_name, memory.tell()))\n       # memlock.release()\n        \n    def read_messages(self):\n        """Usage: component.read_messages => [message1, message2, ...]\n        \n        Returns a list of messages. The list contains all messages sent via\n        the rpc method since the last call to read_messages. Messages in the list\n        are of the bytes/string type"""\n\n        name = self.instance_name\n        memory, pointers = Component_Memory[name]\n        \n        messages = []\n        if pointers:\n            old_pointer = 0\n            for sender, pointer in pointers:\n                messages.append((sender, memory[old_pointer:pointer]))\n                old_pointer = pointer\n            memory.seek(0)\n            Component_Memory[name] = memory, []\n        \n        return messages\n\n    def _make_packet(self, response_to, data):\n        message = response_to + " " + data\n        id = str(hash(message))\n        return id, id + " " + message\n        \n    def react(self):        \n        for sender, packet in self.read_messages():\n    #        print "Received packet: ", packet\n            id, response_to, data = packet.split(" ", 2)            \n            \n            if response_to in self._return_to:\n                command = self._return_to[response_to]\n                old_command, value = data.split(" ", 1)\n            else:\n                command, value = data.split(" ", 1)\n                                       \n            self.alert("handling response {} {}",\n                       [command, value[:32]],\n                       level=\'vv\')\n    #        print "reaction: ", self.instance_name, command, value\n            response = getattr(self, command)(sender, value)\n            \n            if response:                                \n                self.alert("Sending response: {} in response to {}",\n                           [response, id],\n                           level=\'vvv\')\n                self.rpc(sender, response, id)\n            \n    def _resolve_string(self, string):\n        """Given a string of ...x.y.z, import ...x.y and return an instance of z"""\n        module_name = string.split(".")   \n        class_name = module_name.pop(-1)\n        module_name = \'.\'.join(module_name)\n        if not module_name:\n            module_name = "__main__"\n            \n        _from = sys.modules[module_name] if module_name in sys.modules\\\n                else importlib.import_module(module_name)\n\n        return getattr(_from, class_name)\n        \n            \nclass Wrapper(Base):\n    """a class that will act as the object it wraps and as an\n       Rpc_Enabled Base object simultaneously."""\n\n    def __init__(self, **kwargs):\n        """attributes = {"wrapped_object" : wrapped_object, "objects" : {}, "added_to" : set()}\n        if kwargs:\n            attributes.update(kwargs)\n        super(Wrapper, self).attribute_setter(**attributes)"""\n        wraps = super(Wrapper, self).__getattribute__("wraps")\n        try:\n            wrapped_object = kwargs.pop("wrapped_object")\n        except KeyError:\n            pass\n        else:\n            wraps(wrapped_object)\n        super(Wrapper, self).__init__(**kwargs)\n\n    def wraps(self, obj, set_defaults=False):\n        set_attr = super(Wrapper, self).__setattr__\n        if set_defaults:\n            for attribute, value in self.defaults.items():\n                set_attr(attribute, value)\n        set_attr("wrapped_object", obj)\n\n    def __getattribute__(self, attribute):\n        try:\n            wrapped_object = super(Wrapper, self).__getattribute__("wrapped_object")\n            value = super(type(wrapped_object), wrapped_object).__getattribute__(attribute)\n        except AttributeError:\n            value = super(Wrapper, self).__getattribute__(attribute)\n        return value\n\n    def __setattr__(self, attribute, value):\n        try:\n            wrapped_object = self.wrapped_object\n            super(type(wrapped_object), wrapped_object).__setattr__(attribute, value)\n        except AttributeError:\n            super(Wrapper, self).__setattr__(attribute, value)      '
tp16
a(Vdefaults.py
S'#   mpf.defaults - config file - contains attributes:values for new instances\n#\n#    Copyright (C) 2014  Ella Rose\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport struct\nimport socket\nfrom traceback import format_exc\nfrom multiprocessing import cpu_count\nfrom StringIO import StringIO\n\nNO_ARGS = tuple()\nNO_KWARGS = dict()\nPROCESSOR_COUNT = 1#cpu_count()\n\n# Base\n# you can save memory if you have LOTS of objects but\n# few that actually use their memory. note that for reasonable\n# amounts of objects the difference is negligible and\n# not worth the loss of convenience\nMANUALLY_REQUEST_MEMORY = 0\nDEFAULT_MEMORY_SIZE = 4096\nBase = {"memory_size" : DEFAULT_MEMORY_SIZE,\n"network_packet_size" : 4096,\n"verbosity" : \'\',\n"deleted" : False}\n\nProcess = Base.copy()\nProcess.update({"auto_start" : True,\n"network_buffer" : \'\',\n"keyboard_input" : \'\',\n"priority" : .04})\n\nThread = Base.copy()\n\n# vmlibrary\n\nProcessor = Base.copy()\nProcessor.update({"_cache_flush_interval" : 15})\n\nSystem = Base.copy()\nSystem.update({"name" : "system",\n"status" : "",\n"hardware_configuration" : tuple(),\n"startup_processes" : tuple()})\n\nMachine = Base.copy()\nMachine.update({"processor_count" : PROCESSOR_COUNT,\n"system_configuration" : (("vmlibrary.System", NO_ARGS, NO_KWARGS), )})\n\nUser_Input = Process.copy()\n\n# network\n\nSocket = Base.copy()\nSocket.update({"blocking" : 0,\n"timeout" : 0,\n"allow_port_zero" : True,\n"idle" : True,\n"timeout_after" : 0,\n"add_on_init" : True,\n"network_packet_size" : 32768,\n"memory_size" : 32768,\n"network_buffer" : \'\',\n"interface" : "0.0.0.0",\n"port" : 0})\n\nConnection = Socket.copy()\nConnection.update({"socket_family" : socket.AF_INET,\n"socket_type" : socket.SOCK_STREAM})\n\nServer = Connection.copy()\nServer.update({"port" : 80,\n"backlog" : 50,\n"name" : "",\n"reuse_port" : 0,\n"inbound_connection_type" : "network.Inbound_Connection",\n"share_methods" : ("on_connect", "client_socket_recv", "client_socket_send")})\n\nUdp_Socket = Socket.copy()\n\nOutbound_Connection = Connection.copy()\nOutbound_Connection.update({"ip" : "",\n"port" : 80,\n"target" : tuple(),\n"as_port" : 0,\n"connect_attempts" : 10,\n"timeout_notify" : True,\n"add_on_init" : False,\n"bad_target_verbosity" : 0}) # alert verbosity when trying to connect to bad address\ndel Outbound_Connection["interface"]\n\nInbound_Connection = Connection.copy()\n\n# network2\nService = Socket.copy()\nService.update({"resend_limit" : 10,\n"resend_interval" : .2})\n\nAuthenticated_Service = Service.copy()\nAuthenticated_Service.update({"database_filename" : ":memory:",\n"login_message" : \'login success\'})\n\nAuthenticated_Client = Service.copy()\nAuthenticated_Client.update({"email" : \'\',\n"username" : "",\n"password" : \'\'})\n\nService_Listing = Service.copy()\n\nFile_Service = Service.copy()\nFile_Service.update({"network_packet_size" : 16384,\n"mmap_threshold" : 16384,\n"timeout_after" : 15})\n\nDownload = Service.copy()\nDownload.update({"filesize" : 0,\n"filename" :\'\',\n"filename_prefix" : "Download",\n"download_in_progress" : False,\n"network_packet_size" : 16384,\n"timeout_after" : 15})\n\n# only addresses in the range of 224.0.0.0 to 230.255.255.255 are valid for IP multicast\nMulticast_Beacon = Udp_Socket.copy()\nMulticast_Beacon.update({"packet_ttl" : struct.pack("b", 127),\n"multicast_group" : "224.0.0.0",\n"multicast_port" : 1929})\n\nMulticast_Receiver = Udp_Socket.copy()\nMulticast_Receiver.update({"interface" : "0.0.0.0",\n"ip" : "224.0.0.0",\n"port" : 0})\n\nBasic_Authentication_Client = Thread.copy()\nBasic_Authentication_Client.update({"memory_size" : 4096,\n"credentials" : tuple()})\n\nBasic_Authentication = Thread.copy()\nBasic_Authentication.update({"invalid_password_string" : "Invalid Password",\n"invalid_username_string" : "Invalid Username"})\nAsynchronous_Network = Process.copy()\n\nAsynchronous_Network.update({"number_of_sockets" : 0,\n"priority" : .01,\n"update_priority" : 5})\n\n"""# Mail Server\nMail_Server = Process.copy()\nMail_Server.update({"address" : "notreal@inbox.com",\n"mail_server_name" : "metapython_email_server"})"""\n\n # Metapython\nJYTHON = "java -jar jython.jar"\nPYPY = "pypy"\nCPYTHON = "python"\nDEFAULT_IMPLEMENTATION = CPYTHON\n\nShell_Connection = Outbound_Connection.copy()\nShell_Connection.update({"login_attempt_interval" : .05})\n    \nShell = Process.copy()\nShell.update({"username" : "root",\n"password" : "password",\n"prompt" : ">>> ",\n"copyright" : \'Type "help", "copyright", "credits" or "license" for more information.\',\n"auto_start" : False,\n"ip" : "localhost",\n"port" : 40022,\n"startup_definitions" : \'\'})\n\nMetapython = Process.copy()\nMetapython.update({"command" : "shell_launcher.py",\n"implementation" : DEFAULT_IMPLEMENTATION,\n"environment_setup" : ["PYSDL2_DLL_PATH = C:\\\\Python27\\\\DLLs"],\n"interface" : "0.0.0.0",\n"port" : 40022,\n"prompt" : ">>> ",\n"copyright" : \'Type "help", "copyright", "credits" or "license" for more information.\',\n"priority" : .04,\n"interpreter_enabled" : True})\n#"help" : "Execute a python script or launch a live metapython session"})\n'
tp17
a(Vfileio.py
S'import mmap\nimport os\nfrom contextlib import closing\n\nimport mpre.vmlibrary as vmlibrary\nimport mpre.defaults as defaults\nimport mpre.base as base\n\nclass Cached(object):\n    cache = {}\n    handles = {}\n    \n    def __init__(self, function):\n        self.function = function\n        self.cache[function] = {}\n        self.handles[function] = {}\n        \n    def __call__(self, *args, **kwargs):\n        cache = self.cache[self.function]\n        handles = self.handles[self.function]\n        key = str(args) + str(kwargs)\n        \n        if key in cache:\n            result = cache[key]\n            handles[key] += 1\n        else:\n            cache[key] = result = self.function(*args, **kwargs)\n            handles[key] = 1\n         \n        return result\n        \n    def decrement_handle(self, key):\n        function = self.function\n        handles = self.handles[function]\n\n        handles[key] -= 1\n        if not handles[key]:\n            print "deleting cached item", handles[key], key, handles.keys()\n            del self.cache[function][key]\n        else:\n            print "references remaining for", key\n        #self.handles[function][key] = handles[key]\n                \n            \nclass Mmap(object):\n    """Usage: mmap [offset] = fileio.Mmap(filename, \n                                          file_position_or_size=0,\n                                          blocks=0)\n                                 \n        Return an mmap.mmap object. Use of this class presumes a\n        need for a slice into a potentially large file at an arbitrary\n        point without loading the entire file contents. These slices\n        are cached, and the size of the cache may be altered.\n        \n            - if filename is -1 (a chunk of anonymous memory), then no \n              offset is returned. the second argument is interpreted\n              as the desired size of the chunk of memory.\n            - if filename is specified, the second argument is\n              interpreted as the index into the file the slice\n              should be opened to.\n            \n            The default value for the second argument is 0, which will\n            open a slice at the beginning of the specified file\n            \n            - the blocks argument may be specified to request the\n              mapping to be of size (blocks * mmap.ALLOCATIONGRANULARITY)\n            - this argument has no effect when used with -1 for the filename\n            \n            """\n    @Cached\n    def __new__(cls, filename, file_position=0, blocks=0):\n        if filename is -1:\n            return mmap.mmap(-1, file_position)\n            \n        file_size = os.path.getsize(filename)\n        if file_position >= file_size or file_position < 0:\n            raise ValueError             \n        \n        chunk_size = mmap.ALLOCATIONGRANULARITY\n        chunk_number, data_offset = divmod(file_position, chunk_size)\n        #blocks = min(self.max_blocks_per_mmap, blocks)\n                                           \n        # calculate the data\'s displacement + offset into file\n        request_size = file_size if file_size <= chunk_size else chunk_size\n        request_size = blocks * chunk_size if blocks else request_size\n        \n        if file_size - file_position < request_size:\n            length = file_size - chunk_number * chunk_size\n            data_offset = file_position - chunk_number * chunk_size\n        else:\n            length = request_size\n                     \n        file_on_disk = open(filename, \'rb\')\n                    \n        args = (file_on_disk.fileno(), length)        \n        kwargs = {"access" : mmap.ACCESS_READ,\n                  "offset" : chunk_number * chunk_size}\n        \n        memory_map = mmap.mmap(*args, **kwargs)\n                                \n        return memory_map, data_offset\n\n    \nif __name__ == "__main__":\n    def test_case1(filename, iterations=1000):\n        for x in xrange(iterations):\n            f = open(filename, \'rb\')\n            f.close()\n    \n    def test_case2(filename, iterations=1000):\n        for x in xrange(iterations):\n            f = File(filename, \'rb\')\n    \n    from mpre.misc.decoratorlibrary import Timed\n    \n    time = Timed(test_case1)("demofile.exe")\n    time2 = Timed(test_case2)("demofile.exe")\n    print "open: ", time\n    print "Cache:", time2\n    \n    """def test_case(filename, file_position, iterations=100):\n        for x in xrange(iterations):\n            m, offset = Mmap(filename, file_position)\n            \n        print "opened at: ", file_position\n        print "Data offset into block: ", offset\n        print ord(file_data[file_position]), ord(m[offset])\n        assert file_data[file_position] == m[offset] \n        \n    m, offset = Mmap("demofile.exe", 22892790) \n    demofile = "demofile.exe"\n    _file = File(demofile, \'rb\')\n    file_data = _file.read()\n    file_size = len(file_data)\n    print\n    print "file size: ", file_size\n    print\n    \n    for file_position in (22892790, 0, file_size-1):\n        print "testing", file_position\n        test_case(demofile, file_position, iterations=2)"""\n        \n    """for x in xrange(100):\n        m, offset = io_manager.load_mmap("newrecording.wav", 2913000)\n    for y in xrange(100):\n        m2, offset2 = io_manager.load_mmap("testrecording.wav", 3113000)\n    \n    for x in xrange(10):\n        io_manager.load_mmap("newrecording.wav", 3112997)"""'
tp18
a(Vmetapython.py
S'#!/usr/bin/env python\nfrom __future__ import unicode_literals\n\nimport sys\nimport codeop\nimport os\nimport tempfile\nimport traceback\nimport time\nimport cStringIO as StringIO\nfrom contextlib import closing\n\nimport base\nimport vmlibrary\nimport network2\nimport utilities\nimport defaults\nInstruction = base.Instruction\n\n\nclass Interpreter_Client(network2.Authenticated_Client):\n    \n    defaults = defaults.Authenticated_Client.copy()\n    defaults.update({"username" : "ellaphant",\n                     "password" : "puppydog",\n                     "email" : "notneeded@no.com",\n                     "startup_definitions" : \'\',\n                     "target" : ("localhost", 40022)})\n                     \n    def __init__(self, **kwargs):\n        super(Interpreter_Client, self).__init__(**kwargs)\n                \n    def login_result(self, sender, packet):\n        response = super(Interpreter_Client, self).login_result(sender, packet)\n        if self.logged_in:\n            sys.stdout.write(">>> ")\n            if self.startup_definitions:\n                try:\n                    compile(self.startup_definitions, "Interpreter_Client", \'exec\')\n                except:\n                    self.alert("Startup defintions failed to compile:\\n{}",\n                            [traceback.format_exc()],\n                            level=0)\n                else:\n                    self.execute_source(self.startup_definitions) \n\n        return response\n        \n    def execute_source(self, source):\n        self.rpc(self.target, self.exec_code_request(self.target, source))\n        \n    def exec_code_request(self, sender, source):\n        if not self.logged_in:\n            response = self.login(sender, source)\n        else:\n            response = "return result exec_code " + source\n        return response     \n        \n    def result(self, sender, packet):\n        if packet:\n            sys.stdout.write("\\b"*4 + "   " + "\\b"*4 + packet + ">>> ")\n        \n        \nclass Interpreter_Service(network2.Authenticated_Service):\n    \n    defaults = defaults.Authenticated_Service\n    defaults.update({"copyright" : \'Type "help", "copyright", "credits" or "license" for more information.\',\n                     "port" : 40022,\n                     "interface" : "0.0.0.0"})\n    \n    def __init__(self, **kwargs):\n        self.user_namespaces = {}\n        super(Interpreter_Service, self).__init__(**kwargs)\n        self.log_file = open("Metapython.log", \'a\')\n        \n    def login(self, sender, packet):\n        response = super(Interpreter_Service, self).login(sender, packet)\n        if "success" in response.lower():\n            username = self.logged_in[sender]\n            self.user_namespaces[username] = {"__builtins__": __builtins__,\n                                              "__name__" : "__main__",\n                                              "__doc__" : \'\',\n                                              "Instruction" : Instruction}\n                       \n            string_info = (username, sender,\n                           sys.version, sys.platform, self.copyright)\n        \n            greeting = ("Welcome {} from {}\\nPython {} on {}\\n{}\\n".\\\n                        format(*string_info))\n            response = "end_request login_result success " + greeting\n\n        return response\n        \n    @network2.Authenticated\n    def exec_code(self, sender, packet):\n        log = self.log_file\n        \n        username = self.logged_in[sender]\n        log.write("{} {} from {}:\\n".format(time.asctime(), username, sender) + \n                  packet)\n        result = \'\'        \n        try:\n            code = compile(packet, "<stdin>", \'exec\')\n        except (SyntaxError, OverflowError, ValueError):\n            result = traceback.format_exc()\n           \n        else:                \n            backup = sys.stdout            \n            sys.stdout = StringIO.StringIO()\n            \n            try:\n                exec code in self.user_namespaces[username]\n            except BaseException as error:\n                if type(error) == SystemExit:\n                    raise\n                else:\n                    result = traceback.format_exc()\n            finally:\n                sys.stdout.seek(0)\n                result += sys.stdout.read()\n                \n                sys.stdout.close()\n                sys.stdout = backup\n                \n                log.write("{}\\n".format(result))\n        log.flush()\n        return result\n\n        \nclass Shell(base.Base):\n    """Captures user input and passes it to Interpreter_Client"""\n\n    defaults = defaults.Shell\n    \n    exit_on_help = True\n    parser_ignore = ("copyright", "traceback")\n    \n    def __init__(self, **kwargs):\n        super(Shell, self).__init__(**kwargs)\n        self.lines = \'\'\n        self.user_is_entering_definition = False\n        self.interpreter = self.create(Interpreter_Client)\n            \n        self.rpc("User_Input", "add_listener " + self.instance_name)\n        self.definition_finished = False\n                \n    def handle_keystrokes(self, sender, keyboard_input):\n     #   sys.stdout.write(self.instance_name + " received keystrokes " + keyboard_input)\n        self.lines += keyboard_input\n        lines = self.lines\n                \n        if lines != "\\n":            \n            try:\n                code = codeop.compile_command(lines, "<stdin>", "exec")\n            except (SyntaxError, OverflowError, ValueError) as error:\n                sys.stdout.write(traceback.format_exc())\n                raise SystemExit\n                self.prompt = ">>> "\n                self.lines = \'\'\n            else:\n                if code:\n                    if self.user_is_entering_definition:\n                        if lines[-2:] == "\\n\\n":\n                            self.prompt = ">>> "\n                            self.lines = \'\'\n                            self.interpreter.execute_source(lines)\n                            self.user_is_entering_definition = False\n                        \n                    else:\n                        self.lines = \'\'\n                        self.interpreter.execute_source(lines)\n                else:\n                    self.user_is_entering_definition = True\n                    self.prompt = "... "\n        else:\n            self.lines = \'\'\n        \n        sys.stdout.write(self.prompt)\n            \n    \nclass Metapython(base.Base):\n\n    defaults = defaults.Metapython\n\n    parser_ignore = ("environment_setup", "prompt", "copyright", "authentication_scheme",\n                     "traceback", "memory_size", "network_packet_size", \n                     "interface", "port")\n                     \n    parser_modifiers = {"command" : {"types" : ("positional", ),\n                                     "nargs" : \'?\'},\n                        "help" : {"types" : ("short", "long"),\n                                  "nargs" : \'?\'}\n                        }\n    exit_on_help = False\n\n    def __init__(self, **kwargs):\n        super(Metapython, self).__init__(**kwargs)\n                \n        self.setup_environment()\n        \n        if self.interpreter_enabled:\n            Instruction(self.instance_name, "start_service").execute()\n       \n        Instruction(self.instance_name, "exec_command").execute()\n        self.start_machine()\n        \n        self.alert("{} shutting down", [self.instance_name], level=\'v\')\n        \n    def setup_environment(self):\n        modes = {"=" : "equals",\n                 "+=" : "__add__", # append strings or add ints\n                 "-=" : "__sub__", # integer values only\n                 "*=" : "__mul__",\n                 "/=" : "__div__"}\n\n        for command in self.environment_setup:\n            variable, mode, value = command.split()\n            if modes[mode] == "equals":\n                result = value\n            else:\n                environment_value = os.environ[variable]\n                method = modes[mode]\n                result = getattr(environment_value, method)(value)\n            os.environ[variable] = result\n        \n    def exec_command(self):\n        module = open(self.command, \'r\')\n        code = compile(module.read(), \'Metapython\', \'exec\')\n        \n        exec code in globals(), globals()\n\n    def start_machine(self):\n        machine = self.create("vmlibrary.Machine")\n        machine.create("network.Asynchronous_Network")\n        machine.run()       \n    \n    def start_service(self):\n        server_options = {"name" : self.instance_name,\n                          "interface" : self.interface,\n                          "port" : self.port}  \n               \n        self.server = self.create(Interpreter_Service, **server_options)      \n        \n    def exit(self, exit_code=0):\n        Instruction("Processor", "attribute_setter", running=False).execute()\n        # cleanup/finalizers go here?\n\n\nif __name__ == "__main__":\n    Metapython = Metapython(parse_args=True)'
tp19
a(Vnetwork.py
S'#   mpf.network_library - builds on sockets - basic authentication - asynchronous network\n#\n#    Copyright (C) 2014  Ella Rose\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport sys\nimport os\nimport socket\nimport select\nimport struct\nimport errno\nimport time\nimport mmap\nimport contextlib\nimport traceback\nimport getpass\nimport functools\n#import hashlib\n\nimport vmlibrary\nimport defaults\nimport base\nfrom utilities import Latency, Average\nInstruction = base.Instruction\n\ntry:\n    CALL_WOULD_BLOCK = errno.WSAEWOULDBLOCK\n    BAD_TARGET = errno.WSAEINVAL\n    CONNECTION_IN_PROGRESS = errno.WSAEWOULDBLOCK\n    CONNECTION_IS_CONNECTED = errno.WSAEISCONN\n    CONNECTION_WAS_ABORTED = errno.WSAECONNABORTED\nexcept:\n    CALL_WOULD_BLOCK = errno.EWOULDBLOCK\n    CONNECTION_IN_PROGRESS = errno.EINPROGRESS\n    CONNECTION_IS_CONNECTED = errno.EISCONN\n    CONNECTION_WAS_ABORTED = errno.ECONNABORTED\n\n        \nclass Socket(base.Wrapper):\n\n    defaults = defaults.Socket\n\n    def _get_address(self):\n        return (self.ip, self.port)\n    address = property(_get_address)\n\n    def __init__(self, **kwargs):\n        kwargs.setdefault("wrapped_object", socket.socket())\n        super(Socket, self).__init__(**kwargs)\n        self.setblocking(self.blocking)\n        self.settimeout(self.timeout)\n        if self.add_on_init:\n            self.public_method("Asynchronous_Network", "add", self)\n    \n    def delete(self):\n        self.close()        \n        super(Socket, self).delete()\n     \n    def socket_send(self, data):\n        target, message = data\n        self.sendto(message, target)\n                \n    def handle_idle(self):\n        if not self.deleted:\n            if self.idle:\n                self.alert("{0} idle disconnect after {1}s", (self.instance_name, self.timeout_after), 0)\n                self.delete()\n            else:\n                self.idle = True\n                self.idle_instruction.execute()\n        \n        \nclass Connection(Socket):\n\n    defaults = defaults.Connection\n\n    def __init__(self, **kwargs):\n        super(Connection, self).__init__(**kwargs)\n\n    def socket_recv(self):\n        self.network_buffer += self.recv(self.network_packet_size)\n        \n    def socket_send(self, data):\n        self.send(data)\n                \n\nclass Server(Connection):\n\n    defaults = defaults.Server\n\n    def __init__(self, **kwargs):\n        self.client_options = {}\n        super(Server, self).__init__(**kwargs)\n        self.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, self.reuse_port)\n\n        bind_success = True\n        try:\n            self.bind((self.interface, self.port))\n        except socket.error:\n            self.alert("socket.error when binding to {0}", (self.port, ), 0)\n            bind_success = self.handle_bind_error()\n        if bind_success:\n            self.listen(self.backlog)\n\n    def socket_recv(self):\n        _socket, address = self.accept()\n        \n        connection = self.create(self.inbound_connection_type,\n                                  wrapped_object=_socket,\n                                  peer_address=address,\n                                  **self.client_options)\n        self.alert("{} accepted connection {} from {}", \n                  (self.name, connection.instance_name, address),\n                  level="v")\n        \n        self.on_connect(connection)\n\n    def handle_bind_error(self):\n        if self.allow_port_zero:\n            self.bind((self.interface, 0))\n            return True\n        else:\n            self.alert("{0}\\nAddress already in use. Deleting {1}\\n",\n                       (traceback.format_exc(), self.instance_name), 0)\n            instruction = Instruction(self.instance_name, "delete")\n            instruction.execute()\n\n\nclass Outbound_Connection(Connection):\n\n    defaults = defaults.Outbound_Connection\n\n    def __init__(self, **kwargs):\n        super(Outbound_Connection, self).__init__(**kwargs)\n        \n        if not self.target:\n            if not self.ip:\n                self.alert("Attempted to create Outbound_Connection with no host ip or target", tuple(), 0)\n            self.target = (self.ip, self.port)\n\n        self.public_method("Connection_Manager", "add", self)\n                \n    def unhandled_error(self):\n        print "unhandled exception for", self.instance_name\n        self.delete()\n\n    def attempt_connection(self):\n        self.stop_connecting = True\n        if not self.connect_attempts:\n            self.alert("{0} to {1} timed out after {2} frames", (self.instance_name, self.target, self.timeout), 0)\n            self.delete()\n\n        else:\n            self.connect_attempts -= 1\n            try: # non blocking connect\n                self.connect(self.target)\n            except socket.error as socket_error:\n                error = socket_error.errno\n                #self.error_handler.get(error.errno, self.unhandled_error)()\n                if error == CONNECTION_IS_CONNECTED: # complete\n                    self.public_method("Asynchronous_Network", "add", self)\n                    self.on_connect()\n\n                elif error in (CALL_WOULD_BLOCK, CONNECTION_IN_PROGRESS): # waiting\n                    self.alert("{0} waiting for connection to {1}", (self.instance_name, self.target), level="vv")\n                    self.stop_connecting = False\n\n                elif error == BAD_TARGET: #10022: # WSAEINVALID bad target\n                    self.alert("WSAEINVALID bad target for {0}", [self.instance_name], level=self.bad_target_verbosity)\n                    self.delete()\n\n                else:\n                    print "unhandled exception for", self.instance_name\n                    print traceback.format_exc()\n                    self.delete()\n            else:\n                self.on_connect(self)\n\n        return self.stop_connecting\n        \n\nclass Inbound_Connection(Connection):\n\n    defaults = defaults.Inbound_Connection\n\n    def __init__(self, **kwargs):\n        super(Inbound_Connection, self).__init__(**kwargs)\n\n\nclass Udp_Socket(Socket):\n\n    defaults = defaults.Udp_Socket\n\n    def __init__(self, **kwargs):\n        kwargs.setdefault("wrapped_object", socket.socket(socket.AF_INET, socket.SOCK_DGRAM))\n        super(Udp_Socket, self).__init__(**kwargs)        \n        self.network_buffer = {}       \n        \n        self.bind((self.interface, self.port))\n        if not self.port:\n            self.port = self.getsockname()[1]\n            \n        self.settimeout(self.timeout)                       \n             \n    def socket_recv(self):\n        data, address = self.recvfrom(self.network_packet_size)\n        try:\n            self.network_buffer[address] += data\n        except KeyError:\n            self.network_buffer[address] = data\n        \n        \nclass Multicast_Beacon(Udp_Socket):\n\n    defaults = defaults.Multicast_Beacon\n\n    def __init__(self, **kwargs):\n        super(Multicast_Beacon, self).__init__(**kwargs)\n        self.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, self.packet_ttl)\n\n\nclass Multicast_Receiver(Udp_Socket):\n\n    defaults = defaults.Multicast_Receiver\n\n    def __init__(self, **kwargs):\n        super(Multicast_Receiver, self).__init__(**kwargs)\n\n        # thanks to http://pymotw.com/2/socket/multicast.html for the below\n        self.bind((self.listener_address, self.port))\n        group_option = socket.inet_aton(self.multicast_group)\n        multicast_configuration = struct.pack("4sL", group_option, socket.INADDR_ANY)\n        self.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, multicast_configuration)\n\n\nclass Basic_Authentication_Client(vmlibrary.Thread):\n\n    defaults = defaults.Basic_Authentication_Client\n\n    def __init__(self, **kwargs):\n        self.username = \'\'\n        self.password = \'\'\n        self.auto_login = None\n        super(Basic_Authentication_Client, self).__init__(**kwargs)\n        self.thread = self._new_thread()\n        instruction = self.wait_instruction = Instruction(self.instance_name, "wait")\n\n    def run(self):\n        try:\n            next(self.thread)\n        except StopIteration:\n            self.delete()\n\n    def wait(self):\n        self.alert("\\t{0} waiting for reply", [self.instance_name], level="vvv")\n        \n    def _new_thread(self):\n        connection = self.connection\n        \n        username = self.username\n        password = self.password\n        if username:\n            if password:\n                self.alert("Attempting to automatically log in as {0}...",\n                          (username, ), "v")\n            else:\n                password = getpass.getpass()\n        else:\n            username = self.username if self.username else\\\n                       raw_input("Please provide credentials for {0}\\nUsername: "\\\n                                 .format(self.instance_name))\n            password = password if password else getpass.getpass()\n\n        password = hash(password) # WARNING: not seriously secure!\n        response = username+"\\n"+str(password)\n\n        connection.rpc(response)\n        self.wait()\n        yield\n        \n        messages = connection.read_messages()\n        while not messages:\n            self.wait()\n            yield\n            messages = connection.read_messages()\n        \n        reply = messages[0][1].lower()\n        \n        if reply in ("invalid password", "invalid username"):\n            self.alert("{0} supplied in login attempt",\n                      (reply, ), 0)\n            if reply == "invalid password":\n                self.handle_invalid_password()\n            else:\n                self.handle_invalid_username()\n        else:\n            self.handle_success(reply)\n\n    def retry(self):\n        if "y" in raw_input("Retry?: ").lower():\n            self.login_thread = self._new_thread()\n            sefl.wait()\n        else:\n            self.alert("failed to login. Exiting...", level=0)\n\n    def handle_invalid_username(self):\n        self.retry()\n\n    def handle_invalid_password(self):\n        self.retry()\n\n    def handle_success(self, reply=\'\'):\n        Instruction(self.parent, "login_success", reply).execute()\n\n\nclass Connection_Manager(vmlibrary.Thread):\n\n    defaults = defaults.Thread.copy()\n    \n    def _get_buffer(self):\n        return self.objects[socket.socket.__name__]\n    buffer = property(_get_buffer)\n    \n    public_methods = ("add", )\n    \n    def __init__(self, **kwargs):        \n        super(Connection_Manager, self).__init__(**kwargs)\n        self.objects[socket.socket.__name__] = []\n        self.thread = self._new_thread()\n       # self.running = False\n \n    def run(self):\n        return next(self.thread)\n\n    def _new_thread(self):\n        buffer = self.buffer\n        while True:        \n            for connection in buffer:\n                self.remove(connection)\n                if not connection.deleted and not connection.attempt_connection():\n                    self.add(connection)          \n            yield\n           \n\nclass Asynchronous_Network(vmlibrary.Process):\n\n    defaults = defaults.Asynchronous_Network\n\n    def _get_local_services(self):\n        local_names = ("localhost", "0.0.0.0", "127.0.0.1")\n        return dict((key, value) for key, value in self.services.items() if key in local_names)\n    local_services = property(_get_local_services)\n\n    public_methods = ("buffer_data", "add")\n    \n    def __init__(self, **kwargs):\n        # minor optimization\n        # pre allocated slices and ranges\n        self._socket_name = socket.socket.__name__\n        self._slice_mapping = dict((x, slice(x * 500, (500 + x * 500))) for x in xrange(10))\n        self._socket_range_size = range(1)\n        self._select = select.select\n\n        self.write_buffer = {}\n        super(Asynchronous_Network, self).__init__(**kwargs)\n        self.objects[socket.socket.__name__] = []\n                \n        self.connection_manager = self.create(Connection_Manager)\n\n        instruction = self.update_instruction = Instruction("Asynchronous_Network", "_update_range_size")\n        instruction.priority = self.update_priority\n        instruction.execute()\n\n    def buffer_data(self, connection, data, to=None):\n        if to:\n            data = (to, data)\n        try:\n            self.write_buffer[connection].append(data)\n        except KeyError:\n            self.write_buffer[connection] = [data]\n                \n    def debuffer_data(self, connection):\n        try:\n            del self.write_buffer[connection]\n        except KeyError:\n            pass\n        \n    def _update_range_size(self):\n        self._socket_range_size = range((len(self.objects[self._socket_name]) / 500) + 1)\n        self.update_instruction.execute()\n\n    def run(self):\n        self.run_instruction.execute()\n        self.connection_manager.run()\n\n        sockets = self.objects[self._socket_name]\n        for chunk in self._socket_range_size:\n            # select has a max # of file descriptors it can handle, which\n            # is about 500 (at least on windows). We can avoid this limitation\n            # by sliding through the socket list in slices of 500 at a time\n            socket_list = sockets[self._slice_mapping[chunk]]\n\n            readable, writable, errors = self._select(socket_list, socket_list, [], 0.0)\n            if readable:\n                self.handle_reads(readable)\n                \n            if writable:\n                needs_write = ((sock, self.write_buffer.pop(sock)) for sock in \n                                self.write_buffer.keys() if sock in writable)     \n                self.handle_writes(needs_write)\n\n    def handle_errors(self, socket_list):\n        self.alert("Encountered sockets with errors", level=0)\n\n    def handle_reads(self, readable_sockets):\n        for sock in readable_sockets:\n            try:\n                sock.socket_recv()\n            except socket.error as error:\n                if error.errno == CONNECTION_WAS_ABORTED:\n                    sock.close()\n                    sock.delete()\n                elif error.errno == 11: # EAGAIN on unix\n                    self.alert("EAGAIN error reading {0}",\n                              (sock, ), 0)\n                else:\n                    raise\n\n    def handle_writes(self, writable_sockets):\n        for sock, messages in writable_sockets:\n            try:\n                for message in messages:                   \n                    sock.socket_send(message)\n            except socket.error as error:            \n                if error.errno == CONNECTION_WAS_ABORTED:\n                    self.alert("Failed to send {0} on {1}\\n{2}",\n                          (message, sock, error), 0)\n                    sock.delete()\n                    \n                elif error.errno == 11: # EAGAIN on unix\n                    self.alert("EAGAIN error when writing to {0}",\n                            (sock, ), 0)\n                else:\n                    raise'
tp20
a(Vnetwork2.py
S'import os\nimport collections\nimport hmac\nimport getpass\nimport hashlib\nimport sqlite3\nimport binascii\nimport functools\n\nimport mpre.base as base\nimport mpre.defaults as defaults\nimport mpre.network as network\nimport mpre.fileio as fileio\nfrom mpre.utilities import Latency, timer_function\nInstruction = base.Instruction\n           \ndef Authenticated(function):\n    def call(instance, sender, packet):\n        if sender in instance.logged_in:\n            response = function(instance, sender, packet)\n        else:\n            response = "login_result 0"\n        return response\n    return call\n    \n    \n"""class Authenticated(object):\n    \n    def __init__(self, function):\n        self.function = function\n      #  functools.update_wrapper(self, function)\n        \n    def __call__(self, instance, sender, packet):\n        if sender in instance.logged_in:\n            response = self.function(sender, packet)\n        else:\n            response = "login_result 0"\n        return response\n"""\n        \nclass Service(network.Udp_Socket):\n    \n    defaults = defaults.Service\n    \n    end_request_errors = {"0" : "Invalid Request"}\n    \n    def __init__(self, **kwargs):\n        super(Service, self).__init__(**kwargs)\n        self.expecting_response = collections.deque(maxlen=20)\n        self.received = collections.deque(maxlen=20)\n        self.packet_cache = collections.deque(maxlen=20)\n        self._return_to = {}\n        self.sent_at = {}\n        self.resent = set()\n\n    def socket_recv(self):\n        data, address = self.recvfrom(self.network_packet_size + 128)\n        try:\n            self.network_buffer[address].append(data)\n        except KeyError:\n            self.network_buffer[address] = [data]\n                        \n        base.Parallel_Instructions.append(self.instance_name)\n        \n    def react(self):\n        received = self.received\n        for sender, packet in self.read_messages():\n            if sender in base.Component_Resolve.keys():\n                local = True\n            else:\n                local = False\n                \n            id, response_to, data = packet.split(" ", 2)     \n            received.append(response_to)\n            request = (sender, response_to)\n            \n            self.alert("Checking to see if {} is expected",\n                       [request],\n                       level=\'vv\')    \n            try:                   \n                self.expecting_response.remove(request)\n            except ValueError:\n                if response_to == "None":\n                    self.alert("Received a new connection {}",\n                               [id],\n                               \'vv\')\n                else:\n                    self.alert("Received duplicate packet {}",\n                               [id],\n                               level=\'vv\')\n                    if request in self.resent:\n                        self.resent.remove(request)  \n                    else:\n                        continue\n            \n            end_of_request = False\n            if response_to in self._return_to:\n                command = self._return_to[response_to]\n                value = data\n                if value[:11] == "end_request":\n                    value = value[11:]\n                    end_of_request = True\n            else:\n                if data[:11] == "end_request":\n                    data = data[12:]\n                    end_of_request = True\n                try:\n                    command, value = data.split(" ", 1)\n                except ValueError:\n                    continue\n                                       \n            self.alert("handling response {} {}",\n                       [command, value[:32]],\n                       level=\'vv\')\n            #print "reaction: ", self.instance_name, command, value[:45]\n            response = getattr(self, command)(sender, value)\n            \n            if end_of_request:\n                self.alert("Request finished {}",\n                           [request],\n                           \'vv\')\n                continue\n            else:\n                response = response if response else "end_request"\n                expect_response = response[:11] != "end_request"\n                \n                self.alert("Sending response: {} in response to {}",\n                           [response, id],\n                           level=\'vvv\')\n                self.rpc(sender, response, id, expect_response, local)\n        \n        self._handle_resends()\n        \n    def rpc(self, target, data, \n               response_to="None", expect_response=True,\n               local=False):            \n        if not local:\n            reaction = \'\'\n            lowercase_data = data.lower()\n            \n            if lowercase_data[:6] == "return":\n                flag, reaction, data = data.split(" ", 2)\n            \n            id, packet = self.make_packet(response_to, data)\n            \n            if reaction:\n                self._return_to[id] = reaction\n                \n            if target[0] == "localhost":\n                target = ("127.0.0.1", target[1])                            \n            \n            self.public_method("Asynchronous_Network", "buffer_data", \n                               self,\n                               packet,\n                               target)\n            \n            if expect_response:\n                self.expecting_response.append((target, id))\n                \n            self.packet_cache.append((id, packet))\n            self.sent_at[id] = timer_function()\n            self.alert("sent packet {} {} to {} in response to {}",\n                       [id, data[:32], target, response_to],\n                       level=\'vv\')                       \n            \n        else:\n            assert False\n            super(Service, self).rpc(target, data, response_to)\n        \n    def _handle_resends(self):\n        packet_cache = dict((id, packet) for id, packet in self.packet_cache)\n        sent_at = self.sent_at\n        resend_after = .2\n        \n        for target, id in self.expecting_response:\n            if timer_function() - sent_at[id] > resend_after:\n                packet = packet_cache[id]\n                \n                self.alert("Resending {}",\n                           [id],\n                           level=0)\n                        \n                self.public_method("Asynchronous_Network", "buffer_data", \n                                self,\n                                packet,\n                                target)\n                self.resent.add((target, id))        \n        \n    def read_messages(self):\n        messages = super(Service, self).read_messages()\n        for address, packets in self.network_buffer.items():\n            for packet in packets:\n                messages.append((address, packet))\n            self.network_buffer[address] = []\n        \n        return messages            \n     \n    def make_packet(self, response_to, data):\n        message = response_to + " " + data\n        id = str(hash(message))\n        return id, id + " " + message\n               \n    def invalid_request(self, sender, packet):\n        self.alert("Invalid rpc request\\nFrom:{}\\nPacket:{}",\n                   [sender, packet],\n                   level=0)\n                                    \n        return "end_request invalid_request " + packet\n        \n        \nclass Authenticated_Service(Service):\n    \n    defaults = defaults.Authenticated_Service\n                \n    def __init__(self, **kwargs):\n        super(Authenticated_Service, self).__init__(**kwargs)\n        self.invalid_attempts = {}\n        self.logged_in = {}\n        \n        db = self.database = sqlite3.connect("metapython.db")#self.database_filename)\n        db.text_factory = str\n                    \n        db.create_function("encrypt", 1, self._sql_encrypt)\n        cursor = self.cursor = db.cursor()\n        \n        cursor.execute("CREATE TABLE IF NOT EXISTS Credentials(" + \n                       "email TEXT, username TEXT, password TEXT" +\n                       ", address TEXT)")\n                       \n        self._add_user = \'\'\'INSERT INTO Credentials VALUES(?, ?, encrypt(?), ?)\'\'\'\n        self._remove_user = "DELETE FROM Credentials WHERE username=:username"\n        self._select_user = """SELECT username, password FROM Credentials WHERE username = ?"""\n\n    def _sql_encrypt(self, password, salt=None):\n        salt = os.urandom(64) if not salt else salt\n        encrypted = hashlib.pbkdf2_hmac(\'sha512\', \n                                        password.encode(\'utf-8\'), \n                                        salt, \n                                        100000)\n        assert len(encrypted) == 64\n        return salt + encrypted\n            \n    def login(self, sender, packet):\n        username, password = packet.split(" ", 1)\n        \n        if username in self.logged_in.values():\n            return \'login_result failed 1\'\n            \n        database = self.database\n        cursor = self.cursor\n        \n        self.alert("{} attempting to login from {}",\n                   [username, sender],\n                   level=\'v\')                   \n        \n        cursor.execute(self._select_user, [username])       \n        database.commit()            \n        try:\n            username, correct_password = cursor.fetchone()\n        except TypeError as error:\n            response = "register "\n            message = ("Please register username before logging in\\n" +\n                       "Registration requires:" + "\\n\\temail: {}" + \n                       "\\n\\tusername: {}" + "\\n\\tpassword: {}")\n            response += message\n            database.rollback()            \n        else:\n            hashed = self._sql_encrypt(password, correct_password[:64])\n                        \n            if not hmac.compare_digest(hashed, correct_password):\n                invalid_attempts = self.invalid_attempts\n                \n                attempts = invalid_attempts.get(sender, 0)\n                invalid_attempts.setdefault(sender, attempts + 1)\n                response = "failed 0"\n\n            else:\n                self.logged_in[sender] = username\n                response = "success " + self.login_message\n                \n        return "login_result " + response\n        \n    def register(self, sender, packet):\n        database = self.database\n        cursor = self.cursor\n        \n        email, username, password = packet.split(" ", 2)\n\n        self.alert("Registering new user {} {} {}",\n                   [email, username, sender],\n                   level=\'v\')\n       \n        try:\n            cursor.execute(self._add_user, (email, username,\n                                            password, str(sender)))\n            \n        except sqlite3.Error as error:            \n            self.alert("Database error: {}",\n                       [error],\n                       0)\n            database.rollback()\n            response = \'failed\'\n        else:\n            database.commit()\n            response = "success"\n            \n            self.alert("{} {} {} registered successfully",\n                       [username, email, sender],\n                       level=\'vv\')\n        return response\n\n    def logout(self, sender, packet):\n        if sender in self.logged_in:            \n            del self.logged_in[sender]\n    \n    @Authenticated\n    def modify_user(self, sender, packet):\n        mode, user = packet.split(" ", 1)\n        \n        if mode == "remove":\n            self.cursor.execute(self._remove_user, {"Username" : username})\n            self.database.commit()\n            del self.logged_in[user]\n\n      \nclass Authenticated_Client(Service):\n            \n    defaults = defaults.Authenticated_Client\n    \n    login_errors = {"0" : "Invalid username or password",\n                    "1" : "Already logged in"}\n                    \n    def __init__(self, **kwargs):\n        super(Authenticated_Client, self).__init__(**kwargs)\n        target = self.target\n        self.rpc(target, self.login(None, None))\n        self.logged_in = False\n        \n    def login(self, sender, packet):\n        self.alert("Attempting to login", level=\'v\')\n        \n        username = (self.username if self.username else \n                    raw_input("Please provide username for {}: ".format(\n                               self.instance_name)))\n                    \n        password = self.password if self.password else getpass.getpass()\n        return "login {} {}".format(username, password)\n                \n    def register(self, sender, packet):        \n        print packet.format(self.email, self.username, "*" * len(self.password))\n        \n        email = (self.email if self.email else \n                 raw_input("Please register an email address: "))\n                 \n        username = (self.username if self.username else \n                    raw_input("Please register a username: "))\n                    \n        password = self.password if self.password else getpass.getpass()        \n        \n        return "return login register {} {} {}".format(email, username, password)\n        \n    def login_result(self, sender, packet):\n        if "success" in packet:\n            self.alert(packet, level=0)\n            self.logged_in = True\n        elif "register" in packet:\n            return self.register(sender, packet)\n        else:\n            failed, code = packet.split(" ", 1)\n            error = self.login_errors[code]\n            self.alert("Login failed; {}", [error], level=0)\n        \n        \nclass Service_Listing(Service):\n    defaults = defaults.Service.copy()\n    \n    def __init__(self, **kwargs):\n        self.services = {}\n        super(Service_Listing, self).__init__(**kwargs)\n        \n    def set_service(self, sender, packet):\n        service_name, address = packet.split(" ", 1)                \n        self.services[address] = service_name\n        return "set success"\n        \n    def remove_service(self, sender, packet):\n        service_name, address = packet.split(" ", 1)\n        del self.services[address]\n        \n    def send_listing(self, sender, packet):\n        return "\\n".join("Address: {: >20} Service: {: > 5}".format\\\n                        (address, service_info) for  address, service_info\\\n                        in self.services.items())\n            \n           \nclass File_Service(Service):\n    defaults = defaults.File_Service\n    \n    def __init__(self, **kwargs):\n        super(File_Service, self).__init__(**kwargs)\n                \n    def slice_request(self, sender, slice_info):\n        filename, file_position, request_size = slice_info.split()\n        seek_index = int(file_position)\n        request_size = int(request_size)\n        \n        if request_size >= self.mmap_threshold:\n            _file, offset = fileio.Mmap(filename, seek_index)\n            data = _file[offset:offset + request_size]            \n        \n        else:\n            _file = open(filename, \'rb\')\n            _file.seek(seek_index)\n            data = _file.read(request_size)\n            _file.close()\n            \n        self.alert("retrieved {}/{} bytes of data/requested", \n                   [len(data), request_size],\n                   level=\'vv\')\n        return "record_data " + file_position + " " + data        \n        \n    def get_filesize(self, sender, filename):\n        try:\n            response = str(os.path.getsize(filename))\n        except WindowsError:\n            response = "0"\n        return "set_filesize " + response\n                  \n  \nclass Download(Service):\n    \n    defaults = defaults.Download\n    \n    def __init__(self, **kwargs):\n        super(Download, self).__init__(**kwargs)\n        self.data_remaining = 0\n        \n        filename = self.filename\n        self.file = open("{}_{}".format(self.filename_prefix, filename), \'wb\')    \n                \n        self.rpc(self.target, "get_filesize " + filename)                  \n                \n    def make_request(self):\n        if self.bytes_remaining > 0:\n            file_position = self.file.tell()\n            request_size = min(self.bytes_remaining, self.network_packet_size)\n            request = "{} {} {} {}".format("slice_request",\n                                            self.filename, \n                                            file_position, \n                                            request_size)\n        else:\n            request = ""\n            self.alert("finished downloading, sending close request" + "*"*40, level=0)\n            self.file.close()\n        return request\n                \n    def set_filesize(self, sender, value):\n        filesize = int(value)\n        if filesize:\n            self.bytes_remaining = filesize\n            return self.make_request()            \n        else:\n            self.alert("File {} was not available for download from {}",\n                       [filename, self.target])        \n        \n    def record_data(self, sender, data):\n        file_position, file_data = data.split(" ", 1)\n        seek_position = int(file_position)\n        \n        file = self.file\n        file.seek(seek_position)        \n        file.write(data)\n        file.flush()\n        self.bytes_remaining -= file.tell() - seek_position\n        return self.make_request()\n        \n        \nclass Tcp_Service_Proxy(network.Server):\n\n    def __init__(self, **kwargs):\n        super(Tcp_Service_Proxy, self).__init__(**kwargs)\n        self.inbound_connection_type = Tcp_Client_Proxy\n                    \n    def on_connect(self, connection):\n        pass\n        \n        \nclass Tcp_Client_Proxy(network.Inbound_Connection):\n    \n    def socket_recv(self):\n        request = self.recv(self.network_packet_size)        \n        service_name, command, value = request.split(" ", 2)\n        \n        request = "return reply " + command + " " + value\n        self.rpc(service_name, request)\n              \n    def reply(self, sender, packet):\n        self.public_method("Asynchronous_Network", "buffer_data",\n                           self, str(sender) + " " + packet)\n\n                           \nclass Tcp_Service_Test(network.Outbound_Connection):\n    \n    def on_connect(self):        \n        self.public_method("Asynchronous_Network", "buffer_data",\n                           self, "Interpreter_Service login username password")\n                           \n    def socket_recv(self):\n        self.network_buffer += self.recv(self.network_packet_size)\n        print "got results!: ", self.network_buffer\n        \ndef test_proxy():\n    verbosity = \'vvv\'\n    options = {"verbosity" : verbosity,\n               "port" : 40000}\n               \n    options2 = {"verbosity" : verbosity,\n                "target" : ("localhost", 40000)}\n                \n    Instruction("System", "create", "network2.Tcp_Service_Proxy", **options).execute()\n    Instruction("System", "create", "network2.Tcp_Service_Test", **options2).execute()\n    \n    \nif __name__ == "__main__":\n    from mpre.tests.network2 import test_file_service, test_authentication\n   # test_authentication()\n   # test_file_service()\n   # test_proxy()'
tp21
a(Vpackage.py
S'import os\nimport importlib\nimport traceback\nimport contextlib\n\nimport mpre\nimport mpre.base as base\nimport mpre.defaults as defaults\nimport mpre.utilities as utilities\nensure_file_exists = utilities.ensure_file_exists\nensure_folder_exists = utilities.ensure_folder_exists\n\n@contextlib.contextmanager\ndef ignore_instructions():\n    backup = mpre.Instructions\n    try:\n        yield\n    finally:\n        mpre.Instructions = backup\n        \n\nclass Package(base.Base):\n            \n    defaults = defaults.Base.copy()\n    defaults.update({"package_name" : \'\',\n                     "subfolders" : tuple(),\n                     "directory" : \'\',\n                     "store_source" : True,\n                     "make_docs" : True})\n                     \n    def __init__(self, **kwargs):\n        self.files = {}\n        self.file_source = {}\n        super(Package, self).__init__(**kwargs)\n        \n        self.directory = self.directory if self.directory else os.getcwd()\n        \n        if not self.package_name:\n            self.package_name = raw_input("Please provide the package name: ")\n        self.update_structure()\n        \n        if self.make_docs == True:\n            self.create(Documentation, package=self)\n    \n    def init_filename_in(self, path):\n        return os.path.join(path, "__init__.py")\n    \n    @staticmethod\n    def from_directory(top_directory, dirnames):  \n        folder_paths = [(top_directory, os.path.split(top_directory)[-1])]\n        for directory in os.listdir(top_directory):\n            path = os.path.join(top_directory, directory)\n            if os.path.isdir(path):\n                folder_paths.append((path, directory))    \n        \n        file_package = {}            \n        for full_path, folder in folder_paths:\n            file_package[folder] = [os.path.join(full_path, _file) for _file in \n                                    os.listdir(full_path) if "_" != _file[0] and\n                                    os.path.splitext(_file)[-1] == ".py"]\n        return file_package \n    \n    def update_structure(self):\n        directory = self.directory\n        package_name = self.package_name\n        files = self.files\n        \n        folder_path = os.path.join(directory, self.package_name)\n        self.alert("Creating folder structure", level=\'v\')\n        \n        self.make_folder(package_name, folder_path)\n        \n        for subfolder in self.subfolders:\n            print "Building subfolder", subfolder\n            subpath = os.path.join(folder_path, subfolder)\n            self.make_folder(subfolder, subpath)         \n                    \n        self.alert("Finished creating {} folder structure", [self.package_name], level=\'v\')\n  \n    def make_folder(self, subfolder, folder_path):\n        ensure_folder_exists(folder_path)\n        ensure_file_exists(self.init_filename_in(folder_path))\n\n        if subfolder in self.files:\n            self.make_files(subfolder, folder_path, self.files[subfolder])\n            \n    def make_files(self, subfolder, subpath, file_list):\n        new_info = []\n        for file_info in file_list:\n            try:\n                filename, file_data = file_info\n            except ValueError:\n                if not os.path.exists(file_info):\n                    print "path does not exist: ", file_info\n                    assert os.path.exists(file_info)\n                path, filename = os.path.split(file_info)\n                \n                with open(file_info, \'r\') as source_file:\n                    file_data = source_file.read()\n                    source_file.close()                    \n\n            ensure_file_exists(os.path.join(subpath, filename), data=file_data)\n            \n            if self.store_source:\n                new_info.append((filename, file_data))\n                \n        if self.store_source:\n            self.files[subfolder] = new_info\n\n            \nclass Documentation(base.Base):\n    """\n    Generates restructed text .md files from python modules.\n    Writes a mkdocs.yml with the .md files information.\n    Runs mkdocs build to build a site from the .md files\n    """    \n    defaults = defaults.Base.copy()\n    defaults.update({"directory" : os.getcwd(),\n                     "subfolders" : tuple(),\n                     "ignore_directories" : ("docs", ),\n                     "ignore_files" : ("build_documentation.py", ),\n                     "site_name" : \'\',\n                     "verbosity" : \'vv\',\n                     "index_page" : tuple(),\n                     "package" : None})\n                    \n    def __init__(self, **kwargs):\n        super(Documentation, self).__init__(**kwargs)\n        if self.package:\n            package = self.package\n            package_name = self.site_name = package.package_name\n            directory = self.directory = os.path.join(package.directory, package_name)\n            os.chdir(self.directory)\n            docs_directory = os.path.join(directory, "docs")\n            ensure_folder_exists(docs_directory)\n            ensure_file_exists(os.path.join(docs_directory, "index.md"),\n                               data="{}\\n{}".format(package_name, "="*15))\n                  \n        if not self.site_name:\n            self.site_name = raw_input("Please enter site name: ")\n        \n        if not self.index_page:\n            self.index_page = ["index.md", "Homepage"]\n            \n        self.update()\n        \n    def update(self):     \n        directory = self.directory      \n        \n        subfolders = self.subfolders if self.subfolders\\\n                     else [name for name in os.listdir(directory) if \n                           name not in self.ignore_directories and\n                           os.path.isdir(os.path.join(directory, name))]\n                               \n        subfolders.insert(0, directory)\n        \n        package_name = os.path.split(directory)[-1]             \n        site_name = "site_name: {}\\n".format(self.site_name)\n        index_page = self.index_page\n        page_entries = \'\'        \n        page_section = "pages:\\n"\n        page_string = "- [\'{}\', \'{}\', \'{}\']\\n"  \n        \n        md_files = []\n        for subfolder in subfolders:\n            dest_folder = subfolder if subfolder != directory else package_name\n            subfolder_path = os.path.join(directory, subfolder)\n            ensure_folder_exists(os.path.join(directory, "docs", dest_folder))\n            \n            self.alert("\\nWorking on {}", [subfolder], \'v\')\n            \n            py_files = (_file for _file in os.listdir(subfolder_path)\n                        if _file not in self.ignore_files\n                        and "_" != _file[0] # auto ignore private modules\n                        and os.path.splitext(_file)[-1] == ".py")\n                        \n            for python_file in py_files:\n                module_name, py_extension = os.path.splitext(python_file)\n                md_filename = module_name + ".md"\n                \n                if subfolder == directory:\n                    module_path = \'.\'.join((package_name, module_name))                    \n                    md_filepath = os.path.join(directory, "docs", package_name, md_filename)\n                else:\n                    module_path = ".".join((package_name, subfolder, module_name))\n                    md_filepath = os.path.join(directory, "docs", subfolder, md_filename)\n                    \n                self.alert("Importing {}", [module_path], \'vv\')                \n                try:\n                    md_text = self.generate_md_file(module_path)\n                except ImportError:\n                    self.alert("Could not import {}. Could not create .md file\\n{}",\n                               [module_name, traceback.format_exc()],\n                               0)\n                    continue\n                    \n                with open(md_filepath, \'w\') as md_file:\n                    md_file.write(md_text)\n                    md_file.flush()\n                    md_file.close()\n                \n                self.alert("Created md file {}", [md_filepath], level=\'v\')\n                \n                category_name = subfolder if subfolder != directory else package_name\n                page_entries += page_string.format(os.path.join(category_name, md_filename),\n                                                   category_name,  \n                                                   module_name)\n                                                   \n            file_data = "{}{}- {}\\n{}".format(site_name,\n                                              page_section,\n                                              index_page,\n                                              page_entries)\n        self.write_yml_file(file_data)\n        utilities.shell("mkdocs build", shell=True)\n        return file_data        \n        \n    def generate_md_file(self, module_name):\n        """Generates an .md file from a python module"""\n        with ignore_instructions():\n            module = importlib.import_module(module_name)\n            \n        null_docstring = \'No documentation available\'\n        module_docstring = module.__doc__ if module.__doc__ else null_docstring\n            \n        documentation = [\'\'.join((module_name, "\\n========\\n", module_docstring))]\n        _from = getattr(module, "__all__", dir(module))\n            \n        for attribute in getattr(module, "__all__", dir(module)):\n            module_object = getattr(module, attribute)\n            if isinstance(module_object, type) and attribute[0] != "_":\n                docstring = module_object.__doc__ if module_object.__doc__ else null_docstring\n                documentation.append("\\n" + \'\'.join((attribute, "\\n--------\\n", docstring)))\n                    \n        return "\\n".join(documentation)\n        \n    def write_yml_file(self, file_data):\n        with open("mkdocs.yml", "w") as yml_file:\n            yml_file.write(file_data)\n            yml_file.flush()\n            yml_file.close()\n        self.alert("\\n{}", [file_data], level=\'v\')\n        \n        \nif __name__ == "__main__":\n    subfolders = ["test1", "testagain", "lolcool"]\n    files = {"testagain" : ["C:\\\\users\\\\_\\\\pythonbs\\\\mpre\\\\vmlibrary.py"]}\n    test_package = Package(package_name="Test_Package",\n                           subfolders=subfolders,\n                           files=files)'
tp22
a(Vshell_launcher.py
S'import base\nInstruction = base.Instruction\n\noptions = {"parse_args" : True,\n           "startup_definitions" : \'\'}\n\n# feel free to customize\ndefinitions = \\\n"""import base\n\nconstructor = base.Base()\ncreate = constructor.create\n\ndef add_to_network(sock):\n    constructor.public_method("Asynchronous_Network", "add", sock).execute()\n\ndef remove_from_network(sock):\n    Instruction("Asynchronous_Network", "remove", sock).execute()\n\ndef add_network_service(address, name):\n    Instruction("Service_Listing", "add_service", address, name).execute()\n\ndef print_components(mode="keys", size=(None, )):\n    _slice = slice(*size)\n    print getattr(base.Component_Resolve, mode)()[_slice]\n\ndef get_component(instance_name):\n    return base.Component_Resolve[instance_name]\n\ndef processor_usage():\n    Instruction("Processor", "display_processor_usage").execute()\n\ndef delete(instance_name=\'\', instance=None):\n    if instance_name:\n        Instruction(instance_name, "delete").execute()\n    elif instance:\n        instance.delete()\n        \ndef test():\n    Instruction("System", "create", "securitylibrary.DoS", target=("192.168.1.254", 80)).execute()\n    delete = Instruction("DoS", "delete")\n    delete.priority = 1\n    delete.execute()\n\n#Instruction("System", "create", "mpre.audio.audiolibrary.Audio_Manager",\n           #  use_defaults=True).execute()\n            \ndef build_docs(site_name=\'\'):\n    site_name = site_name if site_name else raw_input("Please enter site name: ")\n    \n    Instruction("System", "create", "mpre.docbuilder.Documentation_Builder",\n                 site_name=site_name).execute()\n\n"""\n\noptions["startup_definitions"] += definitions\nmetapython_main = lambda: Instruction("System", "create", "metapython.Shell", **options).execute()\n\nif __name__ == "__main__":\n    Instruction("System", "create", "metapython.Shell", **options).execute()'
tp23
a(Vuserinput.py
S'import sys\nfrom threading import Thread\n\nimport mpre.vmlibrary\ntry:\n    from msvcrt import getwch, kbhit\n    input_waiting = kbhit\nexcept:\n    def input_waiting():\n        return select.select([sys.stdin], [], [], 0.0)[0]\n        \n        \nclass User_Input(mpre.vmlibrary.Process):\n\n    def __init__(self, **kwargs):\n        super(User_Input, self).__init__(**kwargs)\n        self.listeners = []\n        self.thread = Thread(target=self.read_input)\n        \n    def run(self):\n        if input_waiting():\n            self.thread.start()\n        \n        self.run_instruction.execute()\n        \n    def add_listener(self, sender, argument):\n        self.listeners.append(sender)\n        \n    def remove_listener(self, sender, argument):\n        self.listeners.remove(sender)\n        \n    def read_input(self):\n        line = sys.stdin.readline()\n        for listener in self.listeners:\n            # for reasons still not understood by me, if sys.stdout\n            # is not written to here then at random intervals\n            # newline will be written but listener won\'t receive\n            # keystrokes until the next read_input\n            sys.stdout.write(" \\b")\n            self.rpc(listener, "handle_keystrokes " + line)\n        \n        self.thread = Thread(target=self.read_input)'
tp24
a(Vutilities.py
S'#   mpf.utilities - shell commands, latency measurement,\n#                    documentation, running average\n#\n#    Copyright (C) 2014  Ella Rose\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport os\nimport time\nimport inspect\nimport subprocess\nimport collections\n\nif "win" in sys.platform:\n    timer_function = time.clock\nelse:\n    timer_function = time.time\n\ndef shell(command, shell=False):\n    process = subprocess.Popen(command.split(), shell=shell)\n    return process.communicate()[0]\n\ndef ensure_folder_exists(pathname):\n    if not os.path.exists(pathname) or not os.path.isdir(pathname):\n        os.mkdir(pathname)\n  \ndef ensure_file_exists(filepath, data=\'\'):\n    if not os.path.exists(filepath) or not os.path.isfile(filepath):\n        with open(filepath, \'w\') as _file:\n            if data:\n                _file.write(data)\n                _file.flush()\n            _file.close()\n            \n            \nclass Latency(object):\n\n    def __init__(self, name=None, average_size=20):\n        super(Latency, self).__init__()\n        self.name = name\n        self.latency = 0.0\n        self.now = timer_function()\n        self.max = 0.0\n        self.average = Average(size=average_size)\n        self._position = 0\n\n    def update(self):\n        self._position += 1\n        time_before = self.time_before = self.now\n        now = self.now = timer_function()\n        latency = now - time_before\n        self.average.add(latency)\n        if (self._position == 20 or latency > self.max):\n            self.max = latency\n            self._position = 0\n        self.latency = latency\n\n    def display(self, mode="sys.stdin"):\n        if "print" in mode:\n            print "%s Latency: %0.6f, Average: %0.6f, Max: %0.6f" % \\\n            (self.name, self.latency, self.average.average, self.max)\n        else:\n            sys.stdout.write("\\b"*120)\n            sys.stdout.write("%s Latency: %0.6f, Average: %0.6f, Max: %0.6f" % \\\n            (self.name, self.latency, self.average.average, self.max))\n\n\nclass Average(object):\n\n    def _get_meta_average(self):\n        average = self._meta_average.average\n        if not average:\n            average = self.average\n        return average\n    meta_average = property(_get_meta_average)\n\n    def _get_range(self):\n        values = self.values\n        return (min(values), self.average, max(values))\n    range = property(_get_range)\n        \n    def __init__(self, name=\'\', size=20, values=tuple(), meta_average=True):\n        value = meta_average\n        if meta_average:\n            value = Average("{0} meta-average".format(name), 30, meta_average=False)\n        self._meta_average = value\n\n        self.name = name\n        self.values = collections.deque(values, size)\n        self.max_size = size\n        self.size = float(len(self.values))\n        if self.size:\n            self.average = sum(self.values) / self.size\n        else:\n            self.average = 0\n        self.add = self.partial_add\n\n    def partial_add(self, value):\n        self.size += 1\n        self.values.append(value)\n        self.average = sum(self.values) / self.size\n        if self.size == self.max_size:\n            self.add = self.full_add\n\n    def full_add(self, value):\n        old_value = self.values[0]\n        adjustment = (value - old_value) / self.size\n        self.values.append(value)\n        self.average += adjustment\n        if self._meta_average:\n            self._meta_average.add(self.average)\n\n                   \nclass LRU_Cache(object):\n    """A dictionary with a max size that keeps track of\n       key usage and handles key eviction. \n       \n       currently completely untested"""\n    def __init__(self, size=50, seed=None):\n        if seed:\n            assert len(seed.keys()) <= size\n        else:\n            seed = dict()\n        seed = seed if seed else dict()\n        keys = seed.keys()\n        assert len(keys) <= size\n        \n        deque = self.deque = collections.deque(maxlen=size)\n        deque.extend(keys)\n        \n        # testing for x in ... is significantly faster with a set\n        self.contains = set(keys)\n        self.size = size\n        \n        # change implementations once cache is full\n        self.add = self._add\n        \n        # when no entry has been evicted (cache is not full or entry was\n        # already in it), return a non hashable object so all keys \n        # (None, False, etc) will remain valid for users.\n        self.no_eviction = []\n        \n    def _add(self, item):\n        deque = self.deque\n        \n        if item in self.contains:\n            deque.remove(item)\n        else:\n            self.contains.add(item)\n            \n        deque.append(item)\n        if len(deque) > self.size:\n            # change to a slightly different implementation that\n            # doesn\'t do this check when the cache becomes full\n            self.add = _full_add\n        \n        return self.no_eviction\n        \n    def _full_add(self, item):\n        deque = self.deque\n        contains = self.contains\n        \n        if item in contains:\n            deque.remove(item)\n            evicted = self.no_eviction\n        else:\n            contains.add(item)\n            evicted = deque[0]\n        deque.append(item)\n        return evicted\n              \n    def __getitem__(self, key):\n        evicted = self.tracker.add(key)\n        dict = self.dict\n        if evicted is not self.no_eviction:\n            del dict[evicted]\n            self.contains.remove(evicted)\n        return dict[key]\n        \n    def __setitem__(self, key, value):\n        self.dict[key] = value\n        self.contains.add(key)\n\n        \ndef function_header(function, mode="signature"):\n    """function_header(function, [mode]) => "(arg1, default_arg=True, keyword=True...)"\n    \n    Given a function, return it\'s signature. mode can be specified as insertable\n    to use string format insertions instead of argument names"""\n    spec = args, varargs, keyword_args, default_args = inspect.getargspec(function)    \n    \n    header_size = ", ".join("{}" for x in range(len(args)))                \n    header_args = [arg for arg in args]\n    \n    if default_args: \n        new_args = []\n        for arg in default_args:\n            if isinstance(arg, str):\n                new_arg = repr(arg)\n            else:\n                new_arg = arg\n            new_args.append(new_arg)\n        default_args = new_args\n        non_defaults = len(args) - len(default_args)\n        len(default_args)\n        header_args = header_args[:non_defaults] + ["{}={}".format(arg_name, default_args[index]) for index, arg_name in enumerate(header_args[non_defaults:])]\n        \n    if varargs:\n        header_size += ", *{}"\n        header_args.append(varargs)    \n    \n    if keyword_args: \n        insert = "**{}" if mode == "signature" else "**{}"\n        header_size += ", " + insert\n        header_args.append(keyword_args)\n     #   print header_size\n        \n    answer = inserts = "({})".format(header_size)\n    \n    if mode == "signature":\n        answer = inserts.format(*header_args)\n    \n    return answer\n    \n    \ndef documentation(instance):\n    if isinstance(instance, type):\n        _class = instance\n    else:\n        _class = instance.__class__\n    \n    options_text = \'Default values for newly created instances:\\n\\n\'\n    try: # gather the default attribute names and values (base objects only)\n        options = ""\n        for key, value in _class.defaults.items():\n            options += "- {0: <25}{1}\\n".format(key, value)\n        if not options:\n            options_text = "\\nNo defaults are assigned to new instances\\n"\n        else:\n            options_text += options\n    except AttributeError: # does not have defaults\n        options_text = "\\n\\n"\n        \n    docstring = ""\n    class_docstring = getattr(_class, "__doc", \'\')\n    if not class_docstring:\n        class_docstring = getattr(_class, "__doc__", \'\')\n    docstring += "\\t" + class_docstring.replace("    ", \'\').replace("\\n", "\\n\\t") + "\\n\\n" + options_text + "\\n"\n    beginning = docstring    \n        \n    docstring = "This object defines the following non-private methods:\\n"\n    found = False\n    for attribute_name in _class.__dict__.keys():\n        if "_" != attribute_name[0]:\n            attribute = getattr(_class, attribute_name)\n            if callable(attribute):\n                attribute = getattr(attribute, "function", attribute)\n                found = True\n\n                docstring += "\\n\\n- **" + attribute_name + "**"\n                                \n                function_docstring = inspect.getdoc(attribute)\n                function_docstring = function_docstring if function_docstring else "No documentation available"\n\n                try:\n                    method_header = function_header(attribute)\n                except:\n                    print "Could not find header for", attribute\n                    raise SystemExit\n                docstring += method_header + ":\\n\\n\\t\\t  " + function_docstring.replace("\\n", "\\n\\t\\t ") + "\\n"\n                docstring += "\\n"          \n                \n    if found:\n        docstring = beginning + docstring\n    else:\n        docstring = beginning + "No non-private methods are defined\\n"\n    try:\n        mro = str(_class.__mro__).replace("<", "").replace(">", \'\')\n        \n    except AttributeError:\n        docstring += "\\n No method resolution order detected...\\n"\n    else:\n        docstring += "\\nThis objects method resolution order is:\\n\\n"\n        docstring += mro + "\\n"\n    return docstring\n\n\nclass Updater(object):\n\n    def __init__(self):\n        super(Updater, self).__init__()\n\n    def live_update(self, component_name, source):\n        """Updates base component component_name with a class specified in source."""\n        import mpre.base\n        \n        new_component_name = source[source.find("class ")+6:source.find("(")] # scoops Name from "class Name(object):"\n        code = compile(source, "update", "exec")\n        old_component = base.Component_Resolve[component_name]\n        exec code in locals(), globals()\n        new_component_class = locals()[new_component_name]\n        options = {"component" : old_component.parent} # for the Instruction, not actually an instance option\n        for attribute_name in dir(old_component):\n            if "__" not in attribute_name:\n                value = getattr(old_component, attribute_name)\n                if not callable(value):\n                    options[attribute_name] = value\n        new_component = old_component.parent.create(new_component_class, **options)\n        base.Component_Resolve[component_name] = new_component\n'
tp25
a(Vvmlibrary.py
S'#   mpf.vmlibrary - virtual machine - processor - instruction handler\n#\n#    Copyright (C) 2014  Ella Rose\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport pickle\nimport sys\nimport os\nimport atexit\nimport heapq\nimport time\nimport traceback\nimport dis\nfrom cStringIO import StringIO\nfrom collections import deque\nfrom operator import attrgetter\nfrom functools import partial\n\nimport mpre\nimport base\nimport defaults\nimport utilities\n\nInstruction = base.Instruction\ntimer_function = utilities.timer_function\n\nclass Process(base.Base):\n    """a base process for processes to subclass from. Processes are managed\n    by the system. The start method begins a process while the run method contains\n    the actual code to be executed every frame."""\n\n    defaults = defaults.Process\n    parser_ignore = ("auto_start", "network_buffer", "keyboard_input")\n\n    def __init__(self, **kwargs):\n        self.args = tuple()\n        self.kwargs = dict()\n        super(Process, self).__init__(**kwargs)\n\n        run_instruction = self.run_instruction = Instruction(self.instance_name, "run")\n        run_instruction.priority = self.priority\n        run_instruction.log_processor_time = True\n\n        if self.auto_start:\n            self.process("start")\n\n    def process(self, method_name, *args, **kwargs):\n        instruction = Instruction(self.instance_name, method_name, *args, **kwargs)\n        instruction.priority = self.priority\n        instruction.execute()\n\n    def start(self): # (hopeful) compatibility with multiprocessing.Process\n        self.run()\n\n    def run(self):\n        if self.target:\n            self.target(*self.args, **self.kwargs)\n\n        self.run_instruction.execute()\n            \n\nclass Thread(base.Base):\n    """does not run in parallel like threading.thread"""\n    defaults = defaults.Thread\n\n    def __init__(self, **kwargs):\n        self.args = tuple()\n        self.kwargs = dict()\n        self.results = []\n        super(Thread, self).__init__(**kwargs)\n\n    def start(self):\n        self.run()\n\n    def run(self):\n        return self.function(*self.args, **self.kwargs)\n\n\nclass Processor(base.Base):\n\n    defaults = defaults.Processor\n\n    def __init__(self, **kwargs):\n        self.running = True\n        super(Processor, self).__init__(**kwargs)\n        \n    def run(self):\n        instructions = mpre.Instructions\n        parallel_instructions = mpre.Parallel_Instructions\n        Component_Resolve = base.Component_Resolve\n        processor_name = self.instance_name\n        \n        sleep = time.sleep\n        heappop = heapq.heappop\n        _getattr = getattr        \n        \n        component_errors = (AttributeError, KeyError)\n        reraise_exceptions = (SystemExit, KeyboardInterrupt)\n        alert = self.alert\n        component_alert = partial(alert, "{0}: {1} {2} does not exist", level=0)\n        exception_alert = partial(alert, \n                                  "\\nException encountered when processing {0}.{1}\\n{2}", \n                                  level=0)\n        \n        format_traceback = traceback.format_exc\n                \n        while self.running:\n            execute_at, instruction = heappop(instructions)            \n            try:\n                call = _getattr(Component_Resolve[instruction.component_name],\n                                                  instruction.method)               \n            except component_errors as error:                \n                _type = (str(error).replace("Error", \'\') if \n                         type(error) == AttributeError else "component")\n                                \n                component_alert((instruction, instruction.component_name, _type)) \n                continue\n                   \n            alert("{0} executing code {1}", (processor_name, instruction), level="vvv")\n            time_until = max(0, (execute_at - timer_function()))\n            sleep(time_until)       \n            try:\n                call(*instruction.args, **instruction.kwargs)\n            except BaseException as result:\n                if type(result) in reraise_exceptions:\n                    raise\n                exception_alert((instruction.component_name,\n                                 instruction.method,\n                                 format_traceback()))\n        \n            if parallel_instructions:\n                while parallel_instructions:\n                    instance_name = parallel_instructions.pop(0)\n                    Component_Resolve[instance_name].react()\n\n            \nclass System(base.Base):\n    """a class for managing components and applications.\n\n    usually holds components such as the instruction handler, network manager, display,\n    and so on. hotkeys set at the system level will be called if the key(s) are\n    pressed and no other active object have the keypress defined."""\n\n    defaults = defaults.System\n    #hotkeys are specified in the form of keycode:Instruction pairs in a dictionary.\n    # currently not implemented - awaiting pysdl\n    hotkeys = {}\n\n    def __init__(self, **kwargs):\n        # sets default attributes\n        super(System, self).__init__(**kwargs)\n\n        self.alert("{0} starting with {1}", (self.instance_name, str(self.startup_processes)), "v")\n        for component, args, kwargs in self.startup_processes:\n            self.alert("creating {0} with {1} {2}", (component, args, kwargs), "vv")\n            self.create(component, *args, **kwargs)\n\n    def run(self):\n        pass\n\n\nclass Machine(base.Base):\n\n    defaults = defaults.Machine\n\n    def __init__(self, **kwargs):\n        super(Machine, self).__init__(**kwargs)\n\n        for processor_number in range(self.processor_count):\n            self.create(Processor)\n\n        self.create("userinput.User_Input")\n\n        for system_name, args, kwargs in self.system_configuration:\n            system = self.create(system_name, *args, **kwargs)\n\n    def run(self):\n        processor = self.objects["Processor"][0]\n        processor.run()'
tp26
asVprograms
p27
(lp28
(Vbuild_metapython_package.py
S'import os\nimport cPickle as pickle\n\nimport mpre.package\n\noptions = {"verbosity" : "vvv"}   \n                       \ndirectory = options["directory"] = \'C:\\\\users\\\\_\\\\pythonbs\'\npackage_name = options["package_name"] = "mpre"\nsubfolders = options["subfolders"] = ["programs", \'audio\', "gui", "misc"]\n\nif __name__ == "__main__":  \n    files = mpre.package.Package.from_directory(os.path.join(directory,\n                                                             package_name),\n                                                subfolders)\n    options["files"] = files\n    package = mpre.package.Package(**options)\n    with open("mpre.pyp", \'w\') as package_file:\n        pickle.dump(package, package_file)\n        package_file.flush()\n        package_file.close()\n    print "complete!"'
tp29
a(Vbytecodedis.py
S'import ast\nimport sys\nimport dis\nimport ast\nfrom collections import OrderedDict\n\nimport bytecodemap\n\nsymbol_translator = {"*" : "__mul__",\n                     "/" : "__div__",\n                     "+" : "__add__",\n                     "-" : "__sub__"}\n\nblock_stack = [0 for x in xrange(256)]\ncmp_op = dis.cmp_op\nbytecode_counter = []\nopcode = []\ndictionary = {}\n_global = []\ncontinue_loop = []\nTOS = []\nTOS_TOS1 = []\nTOS_TOS2 = []\nTOS_TOS3 = []\ndef translator(statement):\n    if "." in statement:\n        # base.create("testing.Testing")\n        _object, method_call = statement.split(\'.\')\n        method, arguments = method_call.split("(")\n        arguments = "(" + arguments\n    else:\n        _object, method, arguments = statement.split()\n\n    try:\n        method = symbol_translator[method]\n    except KeyError:\n        pass\n    call = getattr(ast.literal_eval(_object), method)\n    return call(ast.literal_eval(arguments))\n\n\nvalid_bytecodes = [opcode for opcode in dis.opname if "<" and ">" not in opcode]\n\n\nclass Bytecode(object):\n\n    def __init__(self, code=None, source=None):\n        if source:\n            code = compile(source, \'bytecode\', \'exec\')\n        elif not code:\n            print "No source or code supplied for Bytecode object"\n            raise SystemExit\n        self.code = code\n        self.opcode_list = []\n        self.code_blocks = []\n        self.address_in = OrderedDict()\n        self.block_jump_table = OrderedDict()\n        self.jump_table = OrderedDict()\n        self.jump_conditions = OrderedDict()\n        self.block_addresses = OrderedDict()\n        self.block_ranges = []\n        self.dump_opcodes()\n\n    def display(self, co_vars=True):\n        if co_vars:\n            co_values = []\n            for co_attr, value in self.dump_co_info():\n                co_values.append((co_attr, value))\n                print co_attr, value\n\n        print\n\n        for address, block in self.block_addresses.items():\n            print"Block {0: ^}".format(address)\n            for opcode in block:\n                print "{0: >15} {1: <20} {2: <2} ({3: <1})".format(*opcode)\n\n    def dump_co_info(self):\n        return ((item, getattr(self.code, item)) for item in dir(self.code) if \'co\' == item[:2])\n\n    def get_block_info(self):\n        block_jump_table = self.block_jump_table\n        block_ranges = self.block_ranges\n        code_blocks = self.code_blocks\n        jump_targets = []\n\n        for block_number, block in enumerate(code_blocks):\n            first_address, _, _, _ = block[0]\n            last_address, _, _, jump_target = block[-1]\n            block_ranges.append(range(first_address, last_address))\n            jump_targets.append((block_number, jump_target))\n\n          #  print "block #{0}: {1} jumps to target {2}".format(block_number, (first_address, last_address), jump_target)\n\n\n\n        for block_number, jump_target in jump_targets:\n            #print "checking block number", block_number\n            for next_block, block_range in enumerate(block_ranges):\n                if jump_target in block_range:\n                    block_jump_table[block_number] = next_block\n                    break\n            #else:\n                #print "block jump from block {1} to address {0} was not in any range".format(jump_target, block_number)\n                #for no, _range in enumerate(block_ranges):\n                 #   print no, _range\n                #raise SystemExit\n        return block_ranges, block_jump_table\n\n    def create_paths(self):\n        block_jump_table = self.block_jump_table\n        code_blocks = self.code_blocks\n        paths = self.paths = {}\n        print\n        for block_number, block in enumerate(code_blocks):\n            index = block_jump_table[block_number]\n           # print "block {0} jumps to block {1}".format(block_number, index)\n            next_block = code_blocks[index]\n            paths[block_number] = (block, next_block)\n\n        return paths\n        """jump_conditions = self.jump_conditions\n        jump_table = self.jump_table\n\n        opcode_list = self.opcode_list\n        block_addresses = self.block_addresses\n        addresses = block_addresses.keys()\n        blocks = block_addresses.values()\n\n        for jump_from, jump_to in jump_table.items():\n            conditional, on_condition = jump_conditions[jump_from]\n\n            if conditional is "forward":\n                pass\n            else:\n                print "Jump from {0} to {1} if {2} is {3}".format(jump_from, jump_to, conditional, on_condition)"""\n\n\n    def get_jump_conditionss(self):\n        opcodes, block_list = self.dump_opcodes()\n        route_number = 0\n        route = {}\n        branches_at = {}\n        jump_conditions = self.jump_conditions\n\n        for block in block_list:\n            for address, opcode, arg_location, arg_name in block:\n                if "JUMP" in opcode:\n                    jump_from = conditional_address\n\n                    if opcode == \'POP_JUMP_IF_FALSE\':\n                        jump_conditions[address] = (conditional, False)\n\n                    elif opcode == "POP_JUMP_IF_TRUE":\n                        jump_conditions[address] = (conditional, True)\n\n                    elif opcode == "JUMP_ABSOLUTE":\n                        jump_conditions[address] = (\'absolute\', \'absolute\')\n\n                    elif opcode == "JUMP_FORWARD":\n                        jump_conditions[address] = ("forward", "forward")\n\n                conditional = arg_name\n                conditional_address = address\n        return jump_conditions\n\n    def dump_opcodes(self):\n        """bytecode.dump_opcodes() => opcodes_list, block_list\n\n        opcodes_list contains address, opcode, arg_address, arg tuples\n        block_list contains block_address, block_code tuples"""\n        code = self.code\n        opcodes = code.co_code\n\n        opcode_list = self.opcode_list\n        jump_table = self.jump_table\n        block_addresses = self.block_addresses\n        code_blocks = self.code_blocks\n\n        block_finished = False\n        block_address = 0\n        block = []\n        block_addresses[0] = block\n\n        argument = False\n        for address, opcode in enumerate(opcodes):\n            index = ord(opcode)\n\n            if not argument:\n\n                if index:\n                    code_name = dis.opname[index]\n                    operation_info = (address, code_name)\n                    argument = index >= dis.HAVE_ARGUMENT\n                    if "JUMP" in code_name:\n                        jump_opcode = code_name\n                        jump_address = address\n                        block_finished = True\n                        #elif code_name == "SETUP_EXCEPT":\n                            #block_finished = False\n                          #  block.append("consolidate")\n                    if not argument:\n                        operation_info += (\'\', \'\')\n                        opcode_list.append(operation_info)\n                        block.append(operation_info)\n\n            else:\n                argument = False\n                arg_value = index + ord(opcodes[address+1]) * 256\n\n                try:\n                    location = bytecodemap.stores_in[code_name]\n                except KeyError:\n                    location = bytecodemap.stack_storage[code_name]\n\n                try:\n                    value = getattr(code, location)\n                except AttributeError:\n                    value = globals()[location]\n\n                try:\n                    _argument = value[index]\n                except IndexError:\n                    unhandled = "{0} argument {1} is unhandled".format(code_name, location)\n                    #print unhandled\n                    _argument = \'\'#(unhandled, value)\n                operation_info += (index, _argument)\n                block.append(operation_info)\n                opcode_list.append(operation_info)\n                if block_finished:\n\n                    if jump_opcode == "JUMP_FORWARD":\n                        _address, _code_name, _location, _arg = block.pop()\n                        _argument = jump_address + index + 3\n                        block.append((_address, _code_name, index, _argument))\n\n                    else:\n                        _address, _code_name, _location, _arg = block.pop()\n                        _argument = _location\n                        block.append((_address, _code_name, _location, _argument))\n\n                    jump_table[jump_address] = _argument\n                    block_finished = False\n                    code_blocks.append(block)\n                    block = []\n                    block_addresses[address + 2] = block\n        else:\n            code_blocks.append(block)\n\n        self.get_block_info()\n        return opcode_list, code_blocks\n\n\ndef attribute_lookup(opcodes, index):\n    position = 0\n    variable_name = opcodes[index][3]\n    names = [variable_name]\n    searching = True\n    \n    while searching:\n        position += 1\n        new_code = opcodes[index - position]\n        new_code_name = new_code[1]\n        new_code_value = new_code[3]\n        \n        if new_code_name in ("LOAD_FAST", "LOAD_GLOBAL", "LOAD_ATTR"):\n            if new_code_value == names[-1]:\n                continue\n            searching = False\n            names.append(new_code_value)\n         #   print "\\t{} is an attribute of {}".format(variable_name, new_code[3])                                            \n    return \'.\'.join(reversed(names))\n    \n\ndef next_stored_variable(opcodes, index):\n    position = 0\n    searching = True\n    while searching:\n        position += 1\n        next_code = opcodes[index + position]\n        next_code_name = next_code[1]\n        \n        if next_code_name in ("STORE_FAST", "STORE_GLOBAL", "STORE_ATTR",\n                              "RETURN_VALUE"):\n            searching = False\n            if next_code_name == "STORE_ATTR":\n                value = attribute_lookup(opcodes, index + position)\n            else:\n                value = next_code[3]\n    return value\n\n    \ndef type_variables(bytecode):\n    name_types = {}\n    equalities = {}\n    \n    opcodes = bytecode.opcode_list\n    for index, code in enumerate(opcodes):\n        code_name = code[1]\n        variable_name = code[3]\n        \n        top_of_stack = opcodes[index - 1]\n        store_code = top_of_stack[1]\n        store_value = top_of_stack[3]\n            \n        if code_name == "INPLACE_ADD":\n            second_of_stack = opcodes[index - 2]\n            second_code = second_of_stack[1]\n            second_value = second_of_stack[3]\n                        \n            if second_code == \'LOAD_CONST\':\n                _type = type(second_value)\n            elif store_code == "LOAD_CONST":\n                _type= type(store_value)\n            \n            variable = next_stored_variable(opcodes, index)\n            name_types[variable] = _type\n            continue\n                \n        if code_name in ("STORE_FAST", "STORE_GLOBAL", "STORE_ATTR",\n                         "RETURN_VALUE"):\n              \n            if code_name == "STORE_ATTR":\n                full_name = attribute_lookup(opcodes, index)\n                equalities[variable_name] = full_name\n                continue\n                \n            if store_code == "LOAD_CONST":\n                if code_name == "RETURN_VALUE":\n                    return_value_info = (type, type(store_value))\n                \n                name_types[variable_name] = type(store_value)\n                \n            if store_code == "LOAD_FAST":\n                print "LOAD_FAST setting equalities[{}] = {}".format(variable_name, store_value)\n                 \n                equalities[variable_name] = store_value\n                \n            if store_code == "LOAD_ATTR":\n                full_name = attribute_lookup(opcodes, index)\n                print "Loaded attribute: ", full_name\n                equalities[variable_name] = full_name\n                \n                if code_name == \'RETURN_VALUE\':\n                    return_value_info = ("equality", full_name)\n                    \n    print "types: ", name_types\n    print "equalities: ", equalities\n    print "return value: ", return_value_info        \n    return name_types, equalities, return_value_info\n \ndef type_names(_dict):\n    return dict((key, type(value)) for key, value in _dict.items())\n    \ndef simpletest():\n    x = 1\n    y = 1.0\n    z = "test_string"\n    boolean = True\n    \n\ndef compile_source(method):\n    bytecode = Bytecode(method.func_code)\n    types, equalities, return_type = type_variables(bytecode)\n    function_source = inspect.getsource(method)\n    declarations = []\n    declare = "cdef {} {}"\n    \n    type_map = {int : "int",\n                float : "double",\n                bool : "bint",\n                str : "str"}\n                \n    for name, _type in types.items():\n        declarations.append(declare.format(type_map[_type], name))\n        \n    start_of_def = function_source.index("def ")\n    end_of_def = function_source.index("):")\n    \n    indent_level = function_source[:end_of_def].count("    ")\n    if not indent_level:\n        indent_level = function_source[:end_of_def].count("\\t")\n    \n    indent = indent_level * "    "\n    code_indent = "\\n{}   ".format(indent)\n    \n    def_header = function_source[:end_of_def + 2]\n    cdef_header = indent + \'c\' + def_header[start_of_def:] + code_indent + " "\n    \n    partial_source = function_source[end_of_def + 2:]\n    \n    compilable_function = cdef_header + code_indent.join(declarations) + "\\n" + partial_source\n    \n    compileable = compilable_function.replace("\\t", \'    \')    \n    print compileable\n    with open("testconvert.pyx", \'w\') as cfile:\n        cfile.write(compileable)\n        cfile.flush()\n        cfile.close()\n\n        \nif __name__ == "__main__":\n    import inspect\n    import mpre.base as base\n    code = base.Base.__init__.func_code\n    global_types = type_names(globals()) \n\n    print inspect.getsource(base.Base.__init__)\n    bytecode = Bytecode(code)\n    bytecode.display(co_vars=False)\n    compile_source(base.Base.__init__)'
tp30
a(Vbytecodemap.py
S'storage = {}\nstores_in = {\'LOAD_GLOBAL\' : \'co_names\',\n             "IMPORT_FROM" : \'co_names\',\n             "IMPORT_NAME" : "co_names",\n             "DELETE_NAME" : "co_names",\n             "STORE_NAME" : "co_names",\n             "LOAD_ATTR" : "co_names",\n             \'STORE_ATTR\' : "co_names",\n             \'DELETE_ATTR\' : "co_names",\n             "LOAD_NAME" : "co_names",\n             \'LOAD_CONST\' : \'co_consts\',\n             \'LOAD_FAST\' : \'co_varnames\',\n             \'STORE_FAST\' : "co_varnames",\n             "DELETE_FAST" : "co_varnames",\n             "LOAD_CLOSURE" : \'co_freevars co_cellvars\',\n             "COMPARE_OP" : "cmp_op",\n             "JUMP_FORWARD" : \'bytecode_counter\',\n             "JUMP_ABSOLUTE" : \'bytecode_counter\',\n             \'POP_BLOCK\' : \'block_stack\',\n             \'SETUP_LOOP\' : "block_stack",\n             "SETUP_EXCEPT" : "block_stack",\n             "SETUP_FINALLY" : "block_stack",\n             "EXTENDED_ARG" : "opcode",\n             \'STORE_MAP\' : "dictionary",\n             "STORE_GLOBAL" : \'_global\',\n             \'DELETE_GLOBAL\' : \'_global\',\n             "ADDRESS" : "continue_loop"}\n\nBYTECODE_COUNTER = ["JUMP_FORWARD", \'JUMP_ABSOLUTE\']\n\nCMP_OP = [\'COMPARE_OP\']\n\nBLOCK_STACK = [\'POP_BLOCK\', \'SETUP_LOOP\', \'SETUP_EXCEPT\', \'SETUP_FINALLY\']\n\nOPCODE = [\'EXTENDED_ARG\']\n\nDICTIONARY = [\'STORE_MAP\']\n\nGLOBAL = [\'STORE_GLOBAL\', \'DELETE_GLOBAL\']\n\nADDRESS = ["CONTINUE_LOOP"]\n\n# PRINT_ITEM_TO uses second to top of stack\nTOS = ["POP_TOP", "ROT_TWO", \'ROT_THREE\', \'ROT_FOUR\', \'DUP_TUP\',\n       \'UNARY_POSITIVE\', \'UNARY_NEGATIVE\', \'UNARY_NOT\', \'UNARY_CONVERT\',\n       \'UNARY_INVERT\', \'GET_ITER\', \'SLICE+0\', "DELETE_SLICE+0",\n       \'PRINT_EXPR\', \'PRINT_ITEM\', \'PRINT_ITEM_TO\', \'PRINT_NEWLINE_TO\',\n       "LIST_APPEND", "LOAD_LOCALS", "RETURN_VALUE", "YIELD_VALUE",\n       \'IMPORT_STAR\', \'SETUP_WITH\', \'STORE_NAME\', \'UNPACK_SEQUENCE\',\n       \'LOAD_CONST\', \'LOAD_NAME\', \'BUILD_TUPLE\', \'BUILD_LIST\', \'BUILD_MAP\',\n       \'LOAD_ATTR\', \'LOAD_GLOBAL\', \'LOAD_FAST\', \'STORE_FAST\', \'LOAD_CLOSURE\',\n       \'LOAD_DEREF\', \'STORE_DEREF\', \'CALL_FUNCTION\', \'MAKE_FUNCTION\',\n       \'CALL_FUNCTION_VAR\', \'CALL_FUNCTION_KW\', \'CALL_FUNCTION_VAR_KW\',\n       "FOR_ITER"]\n\nTOS_TOS1 = [\'BINARY_POWER\', \'BINARY_MULTIPLY\', \'BINARY_DIVIDE\',\n            \'BINARY_FLOOR_DIVIDE\', \'BINARY_TRUE_DIVIDE\', \'BINARY_MODULO\',\n            \'BINARY_ADD\', \'BINARY_SUBTRACT\', \'BINARY_SUBSCR\',\n            \'BINARY_LSHIFT\', \'BINARY_RSHIFT\', \'BINARY_AND\', \'BINARY_XOR\',\n            \'BINARY_OR\', "SLICE+1", "SLICE+2", \'STORE_SLICE+0\',\n            \'DELETE_SLICE+1\', \'DELETE_SLICE+2\', \'STORE_ATTR\', \'DELETE_ATTR\',\n            \'IMPORT_NAME\', \'POP_JUMP_IF_TRUE\', \'POP_JUMP_IF_FALSE\',\n            \'JUMP_IF_TRUE_OR_POP\', \'JUMP_IF_FALSE_OR_POP\', \'MAKE_CLOSURE\',\n            \'BUILD_SLICE\',\'INPLACE_POWER\', \'INPLACE_MULTIPLY\', \'INPLACE_DIVIDE\',\n            \'INPLACE_FLOOR_DIVIDE\', \'INPLACE_TRUE_DIVIDE\', \'INPLACE_MODULO\',\n            \'INPLACE_ADD\', \'INPLACE_SUBTRACT\', \'INPLACE_LSHIFT\', \'INPLACE_RSHIFT\',\n            \'INPLACE_AND\', \'INPLACE_XOR\', \'INPLACE_OR\']\n\nTOS_TOS2 = ["SLICE+3", \'STORE_SLICE+1\', \'STORE_SLICE+2\', \'DELETE_SLICE+3\',\n            \'STORE_SUBSCR\', \'DELETE_SUBSCR\', \'EXEC_STMT\', \'BUILD_CLASS\',\n            "WITH_CLEANUP", \'RAISE_VARARGS\', \'BUILD_SLICE\']\n\nTOS_TOS3 = [\'STORE_SLICE+3\']\n\nstack_storage = {}\nSTACK = [(\'TOS\', TOS), (\'TOS_TOS1\', TOS_TOS1),\n         (\'TOS_TOS2\', TOS_TOS2), (\'TOS_TOS3\', TOS_TOS3)]\nfor stack_size, stack_users in STACK:\n    for user in stack_users:\n        stack_storage[user] = stack_size\n\n_range3 = range(0, 4)\nSLICE = ["SLICE+{}".format(count) for count in _range3]\nSTORE_SLICE = ["STORE_{}".format(slice) for slice in SLICE]\nDELETE_SLICE = ["DELETE_{}".format(slice) for slice in SLICE]\n'
tp31
a(Vcompile.py
S'if __name__ == "__main__":\n    import os\n    import sys\n    from math import sqrt\n    from multiprocessing import Process\n    from _compile import py_to_compiled\n    MAX_PROCESSES = 10\n        \n    # convert .py files in this directory to .pyd or .so (windows/linux)\n    shared_filetype = "pyd" if "win" in sys.platform else "so"\n    directory = os.getcwd()\n    _, _, file_list = next(os.walk(directory))\n    file_list = [_file for _file in file_list if "py" == _file.split(".")[-1]]\n    try:\n        main_file = sys.argv[1]\n    except IndexError:\n        main_file = None\n    else:\n        file_list.remove(main_file)\n    \n   # file_list = ["pagebuilder.py"]\n    print main_file, file_list\n    file_count = len(file_list)    \n    process_count = min(MAX_PROCESSES, int(sqrt(file_count)))\n    files_per_process = len(file_list) / process_count \n    \n    # maps consecutive ints (0, 1, 2...) to slices like [0:files_per_process]\n    slices = dict((index, slice(index * files_per_process, (index + 1) *files_per_process)) for index in range(files_per_process))\n    \n    processes = []\n    for file_count in range(files_per_process):\n        processes.append(Process(target=py_to_compiled, \n                                 args=[file_list[slices[file_count]],\n                                       shared_filetype]\n                                 ))\n    print "beginning compilation..."\n    for process in processes:\n        process.start()\n        \n    print "waiting for shared resources to finish compiling..."        \n    for process in processes:\n        \n        process.join()\n        \n    if main_file:\n        print "compiling executable..."\n        executable = py_to_compiled([main_file], \'exe\')\n        print "...done"'
tp32
a(Vcreate_package.py
S'import mpre.package\n\n    \nif __name__ == "__main__":\n    Instruction("Metapython", "exit").execute()\n    package = mpre.package.Package(parse_args=True)\n    '
tp33
a(Vdownload_file.py
S'import mpre.base as base\n\ndef metapython_main():\n    constructor = base.Base()\n\n    options = {"parse_args" : True,\n           "exit_when_finished" : True}\n    constructor.create("mpre.network2.Download", **options)\n           \nif __name__ == "__main__":\n    metapython_main()\n'
tp34
a(Vfile_server.py
S'import mpre.base as base\n\ndef metapython_main():\n    base.Instruction("System", "create", "network2.File_Service", parse_args=True).execute()\n\nif __name__ == "__main__":\n    metapython_main()\n'
tp35
a(Vget_modules.py
S'import pydoc\nfrom StringIO import StringIO\n\nclass Module_Listing(object):\n\n    def __init__(self, **kwargs):\n        super(Module_Listing, self).__init__()\n        [setattr(self, key, value) for key, value in kwargs.items()]\n        setattr(self, "file", getattr(self, "file", StringIO()))\n\n    def from_help(self):\n        helper = pydoc.Helper(output=self.file)\n        helper("modules")\n\n    def read_file(self):\n        file = self.file\n        file.seek(0)\n        text = file.read()\n        return text\n\n    def trim(self, text):\n        _file = StringIO(text)\n        found = []\n        count = 0\n        for line in _file.readlines():\n            if line.split(" ").count("") > 2:\n                found += line.split()\n\n        return \' \'.join(found)\n\n    def get_modules(self):\n        self.from_help()\n        original = self.read_file()\n        return self.trim(original)\n\n    def make_file(self, filename):\n        with open(filename, \'w\') as _file:\n            _file.write(self.get_modules())\n            _file.flush()\n            _file.close()\n'
tp36
a(Vremote_connection.py
S'#   mpf.remote_connection - connect to another virtual machines Metapython service\n#\n#    Copyright (C) 2014  Ella Rose\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\nimport mpre.base as base\n\ndef metapython_main():\n    base.Instruction("System", "create", "network.Outbound_Connection", parse_args=True).execute()\n    \nif __name__ == "__main__":\n    metapython_main()'
tp37
a(Vsend_file.py
S'#   mpf.send_file - sends a file via udp to the specified address\n\nimport mpre.base as base\nInstruction = base.Instruction\n\ndef metapython_main():\n    Instruction("System", "create", "network2.File_Service", exit_when_finished=True).execute()\n    Instruction("File_Service", "send_file", parse_args=True).execute()\n    \nif __name__ == "__main__":\n    metapython_main()'
tp38
a(Vstupidreceive.py
S'from socket import *\n\nif __name__ == "__main__":\n    receiver = socket(AF_INET, SOCK_STREAM)\n    receiver.bind(("0.0.0.0", 40021))\n    receiver.listen(1)\n    f = open("audiofli.wav", "wb")\n    connection, _from = receiver.accept()\n    downloading = True\n    print "downloading"\n    while downloading:\n        data = connection.recv(4096)\n    \n        if not data:\n            downloading = False\n    \n        f.write(data)\n        f.flush()\n    print "finished"\n'
tp39
a(Vstupidsend.py
S'from socket import *\nfrom sys import argv\n\nif __name__ == "__main__":\n    filename = argv[1]\n    \n    sender = socket(AF_INET, SOCK_STREAM)\n    sender.connect(("192.168.1.240", 40021))\n    print "connected"\n    f = open(filename, "rb")\n    data = f.read()\n    f.close()\n    print len(data)\n    while data:\n        sender.send(data[:4096])\n        data = data[4096:]\n        print len(data), "remaining"\n    print "finished"\n'
tp40
asVdocs
p41
(lp42
sVgui
p43
(lp44
(Vdefaults.py
S'import mpre.defaults as defaults\nBase = defaults.Base\nProcess = defaults.Process\n\nSCREEN_SIZE = [800, 600]\nR = 45\nG = 150\nB = 245\n\n# sdllibrary\n\nSDL_Component = Base.copy()\n\nWorld = SDL_Component.copy()\nWorld.update({"displays" : ({"display_number" : 0}, )})\n\nSDL_Window = SDL_Component.copy()\nSDL_Window.update({"size" : SCREEN_SIZE,\n"showing" : True,\n"layer" : 0,\n"name" : "Metapython",\n"color" : (0, 0, 0),\n"x" : 0,\n"y" : 0})\n\nRenderer = SDL_Component.copy()\nRenderer.update({"componenttypes" : tuple()})\n\nUser_Input = Process.copy()\n#User_Input.update({"priority" : .01})\n\nSprite_Factory = SDL_Component.copy()\n\nFont_Manager = SDL_Component.copy()\nFont_Manager.update({"font_path" : "./resources/fonts/Aero.ttf",\n"default_font_size" : 14,\n"default_color" : (15, 180, 35),\n"default_background" : (0, 0, 0)})\n\n# guilibrary\n\nOrganizer = Process.copy()\nOrganizer.update({"priority" : 0})\n\nWindow_Object = Base.copy()\nWindow_Object.update({\'x\' : 0,\n\'y\' : 0,\n\'size\' : SCREEN_SIZE,\n"layer" : 1,\n"color" : (R, G, B),\n"outline_width" : 5,\n"popup" : False,\n"pack_mode" : \'\',\n"held" : False,\n"pack_modifier" : \'\',\n"color_scalar" : .6,\n"pack_on_init" : True})\n\nWindow = Window_Object.copy()\nWindow.update({"show_title_bar" : False,\n"pack_mode" : "layer"})\n\nContainer = Window.copy()\nContainer.update({"alpha" : 1,\n"pack_mode" : "vertical"})\n\nButton = Container.copy()\nButton.update({"shape" : "rect",\n"text" : "Button",\n"text_color" : (255, 130, 25)})\n\n\n# widgetlibrary\nPopup_Menu = Container.copy()\nPopup_Menu.update({"popup" : True,\n"pack_modifier" : lambda parent, child: setattr(child, "position", (SCREEN_SIZE[0]/2, SCREEN_SIZE[1]/2))})\n\nFile_Menu = Popup_Menu.copy()\nFile_Menu.update({"pack_mode" : "vertical",\n        "pack_modifier" : lambda parent, child: setattr(child, "y", child.y+parent.size[1])})\n\nRight_Click_Menu = Popup_Menu.copy()\nRight_Click_Menu.update({"pack_mode": "layer",\n"size" : (200, 150)})\n\nRight_Click_Button = Button.copy()\n\nHomescreen = Window.copy()\nHomescreen.update({"background_filename" : "C:\\\\test.jpg"})\n\nProperty_Editor = Window.copy()\nProperty_Editor.update({"pack_modifier" : lambda parent, child:\\\nsetattr(child, "position", (SCREEN_SIZE[0]/2, SCREEN_SIZE[1]/2))})\n\nMenu_Bar = Container.copy()\nMenu_Bar.update({"pack_mode" : "menu_bar"})\n\nTitle_Bar = Menu_Bar.copy()\nTitle_Bar.update({"pack_modifier" : lambda parent, child:\\\nsetattr(child, "y", child.y+child.size[1])})\n\nTask_Bar = Menu_Bar.copy()\nTask_Bar.update({"pack_modifier" : lambda parent, child:\\\nsetattr(child, "y", (parent.y+parent.size[1])-child.size[1])\\\n}) # ^ aligns the bottom left corners of the parent and child object\n\nDate_Time_Button = Button.copy()\nDate_Time_Button.update({"pack_mode" : "horizontal"})\n\nHelp_Bar = Button.copy()\nHelp_Bar.update({"pack_mode" : "horizontal"})\n\nProperty_Button = Button.copy()\nProperty_Button.update({"property" : \'\',\n"display" : False})\n\nFile_Button = Button.copy()\nFile_Button.update({"display" : False})\n\nText_Line = Button.copy()\nText_Line.update({"edit_mode" : False})\n\nText_Character = Button.copy()\nText_Character.update({"text" : "",\n        "pack_mode" : "text",\n        "outline" : 0})\n'
tp45
a(Vguilibrary.py
S'import heapq\nimport ctypes\nfrom operator import attrgetter\nfrom sys import modules\nfrom math import floor, sqrt\n\nimport mpre.base as base\nimport mpre.vmlibrary as vmlibrary\nimport defaults\nimport mpre.utilities as utilities\nInstruction = base.Instruction\n\nimport sdl2\nimport sdl2.ext\nSDL_Rect = sdl2.SDL_Rect\n\nR, G, B, A = 0, 80, 255, 30\ndark_color_scalar = .5\nlight_color_scalar = 1.5\n\n\n# provides the pack() functionality\nclass Organizer(vmlibrary.Process):\n\n    defaults = defaults.Organizer\n\n    def __init__(self, *args, **kwargs):\n        super(Organizer, self).__init__(*args, **kwargs)\n        self.queue = []\n        self.running = False\n\n    def pack(self, item):\n        #print "adding to pack queue", item\n        self.queue.append(item)\n        if not self.running:\n            self.running = True\n            self.process("run")\n\n    def run(self):\n        queue = self.queue\n        while queue:\n            item = queue.pop(0)\n            print "packing", item.instance_name, item.pack_mode\n            print "stats before: ", item.area, item.layer\n            parent_queue = item.parent.draw_queue\n            try:\n                count = parent_queue.index(item)\n                length = len(parent_queue)\n            except ValueError:\n                count = 0\n                length = 1\n            pack = getattr(self, "pack_{0}".format(item.pack_mode))\n            pack(item, count, length)\n            print "stats after: ", item.area, item.layer\n        self.running = False\n\n    def pack_horizontal(self, item, count, length):\n        parent = item.parent\n        item.layer = parent.layer + 1\n        item.size = (parent.size[0]/length, parent.size[1])\n        item.x = (item.size[0]*count)+parent.x\n        item.y = parent.y\n\n    def pack_vertical(self, item, count, length):\n        parent = item.parent\n        item.layer = parent.layer + 1\n        item.size = (parent.size[0], parent.size[1]/length)\n        item.y = (item.size[1]*count)+parent.y\n        item.x = parent.x\n\n    def pack_grid(self, item, count, length):\n        grid_size = sqrt(length)\n\n        if grid_size != floor(grid_size):\n            grid_size = floor(grid_size)+1\n\n        position = (int(floor((count / grid_size))), (count % grid_size))\n\n        parent = item.parent\n        item.layer = parent.layer + 1\n        item.size = int(parent.size[0]/grid_size), int(parent.size[1]/grid_size)\n        item.x = (item.size[0]*position[1])+parent.x\n        item.y = (item.size[1]*position[0])+parent.y\n\n    def pack_text(self, item, count, length):\n        parent = item.parent\n        item.layer = parent.layer + 1\n        item.x = parent.x + parent.x_width + parent.x_spacing\n        item.y = parent.y\n\n    def pack_menu_bar(self, item, count, length):\n        parent = item.parent\n        item.layer = parent.layer + 1\n        item.x = parent.x\n        item.y = parent.y\n        item.size = (parent.size[0], int(parent.size[1]*.03))\n\n    def pack_layer(self, item, count, length):\n        parent = item.parent\n        item.layer = parent.layer + 1\n\n    #def pack_center(self, item):\n     #   item.x = Display.SCREEN_SIZE[0]/2\n      #  item.y = Display.SCREEN_SIZE[1]/2\n\n\n\nclass Window_Object(base.Base):\n\n    # default values\n    defaults = defaults.Window_Object\n    Hotkeys = {}\n    def _get_position(self):\n        return (self.x, self.y)\n    def _set_position(self, position):\n        self.x, self.y = position\n    position = property(_get_position, _set_position)\n\n    def _get_area(self):\n        size = self.size\n        return (self.x, self.y, size[0], size[1])\n    def _set_area(self, rect):\n        self.position, self.size = rect\n    area = property(_get_area, _set_area)\n\n    # calculates the outline color\n    def _get_outline_color(self):\n        return (int(self.color[0]*self.color_scalar), int(self.color[1]*\\\n        self.color_scalar), int(self.color[2]*self.color_scalar))\n\n    outline_color = property(_get_outline_color)\n\n    def _get_rect(self):\n        return sdl2.SDL_Rect(*self.area)\n    rect = property(_get_rect)\n\n    def __init__(self, **kwargs):\n        self.draw_queue = []\n        super(Window_Object, self).__init__(**kwargs)\n\n     #   if self.draw_on_init:\n      #      self.draw_texture()\n\n    def create(self, *args, **kwargs):\n        kwargs["sdl_window"] = self.sdl_window\n        kwargs["layer"] = self.layer + 1\n        instance = super(Window_Object, self).create(*args, **kwargs)\n\n        if hasattr(instance, "draw_texture"):\n            self.draw_queue.append(instance)\n            instance.added_to.add(self.instance_name)\n        return instance\n\n    def press(self, mouse):\n        self.held = True\n\n    def release(self, mouse):\n        self.held = False\n        self.click(mouse)\n\n    def click(self, mouse):\n        if mouse.button == 3:\n            args = (self.instance_name, "create", "widgetlibrary.Right_Click_Menu")\n            options = {"x" : mouse.x,\n                       "y" : mouse.y,\n                       "target" : self}\n            Instruction(*args, **options).execute()\n            draw = Instruction(self.instance_name, "draw_texture")\n            draw.component = self\n            draw.execute()\n\n    def mousewheel(self, x_amount, y_amount):\n        pass\n\n    def mousemotion(self, x_change, y_change):\n        if self.held:\n            self.draw("fill", self.area, color=self.parent.color)\n            self.x += x_change\n            self.y += y_change\n            for item in self.draw_queue:\n                original = item.held\n                item.held = True\n                item.mousemotion(x_change, y_change)\n                item.held = original\n            try:\n                self.parent.draw_texture()\n            except AttributeError:\n                self.draw_texture()\n\n    def draw(self, figure="rect", *args, **kwargs):\n        Instruction(self.sdl_window, "draw", self.instance_name, figure, self.area, self.layer, *args, **kwargs).execute()\n\n    def draw_texture(self):\n        area = self.area\n        draw = self.draw\n        draw("fill", area, color=self.color)\n        draw("rect", area, color=self.outline_color)\n        for item in self.draw_queue:\n            item.draw_texture()\n\n    def pack(self, reset=False):\n        if reset:\n            self.x = self.y = 0\n        Instruction("Organizer", "pack", self).execute()\n        for item in self.draw_queue:\n            item.pack()\n\n    def delete(self):\n        self.parent.draw_queue.remove(self)\n        super(Window_Object, self).delete()\n\n\nclass Window(Window_Object):\n\n    defaults = defaults.Window\n\n    def __init__(self, **kwargs):\n        super(Window, self).__init__(**kwargs)\n\n       # if getattr(self, "title_bar", None):\n        #    self.create("widgetlibrary.Title_Bar")\n\n\nclass Container(Window_Object):\n\n    defaults = defaults.Container\n\n    def __init__(self, **kwargs):\n        super(Container, self).__init__(**kwargs)\n\n\nclass Button(Window_Object):\n\n    defaults = defaults.Button\n\n    def __init__(self, **kwargs):\n        super(Button, self).__init__(**kwargs)\n\n    def draw_texture(self):\n        super(Button, self).draw_texture()\n        self.draw("text", self.text, self.area, color=self.text_color)\n'
tp46
a(Vsdllibrary.py
S'import sys\nimport string\nimport heapq\nimport ctypes\nimport mmap\nfrom operator import itemgetter\n\nimport sdl2\nimport sdl2.ext\nimport sdl2.sdlttf\nsdl2.ext.init()\nsdl2.sdlttf.TTF_Init()\nfont_module = sdl2.sdlttf\n\nimport mpre.base as base\nimport mpre.vmlibrary as vmlibrary\nimport mpre.utilities as utilities\nimport defaults\nInstruction = base.Instruction\n\n\nclass Display_Wrapper(base.Wrapper):\n    """used by the display internally to display all objects"""\n    defaults = defaults.Window_Object\n\n    def _get_position(self):\n        return (self.x, self.y)\n    def _set_position(self, position):\n        self.x, self.y = position\n    position = property(_get_position, _set_position)\n\n    def _get_area(self):\n        return (self.position, self.size)\n    def _set_area(self, rect):\n        self.position, self.size = rect\n    area = property(_get_area, _set_area)\n\n    def _get_outline_color(self):\n        return (int(self.color[0]*self.color_scalar), int(self.color[1]*\\\n        self.color_scalar), int(self.color[2]*self.color_scalar))\n    outline_color = property(_get_outline_color)\n\n    def __init__(self, **kwargs):\n        super(Display_Wrapper, self).__init__(**kwargs)\n\n     #   Instruction("Organizer", "pack", wrapped_object).execute()\n      #  Instruction("Display", "draw", wrapped_object).execute()\n\n    def press(self):\n        self.held = True\n\n    #def release(self):\n     #   self.held = False\n      #  if Display.mouse_is_inside(self):\n       #     self.click()\n\n    def click(self):\n        pass\n\n\nclass SDL_Component(base.Wrapper):\n\n    defaults = defaults.SDL_Component\n\n    def __init__(self, **kwargs):\n        super(SDL_Component, self).__init__(**kwargs)\n\n\nclass SDL_Window(SDL_Component):\n\n    defaults = defaults.SDL_Window\n\n    def __init__(self, **kwargs):\n        self.draw_queue = []\n        self.coordinate_tracker = {}\n        self.latency = utilities.Latency(name="framerate")\n        self.queue_counter = 0\n        self.running = False\n        super(SDL_Window, self).__init__(**kwargs)\n\n        window = sdl2.ext.Window(self.name, size=self.size)\n        self.wraps(window)\n\n        renderer = self.renderer = self.create(Renderer, window=self)\n        self.user_input = self.create(User_Input)\n\n        methods = ("point", "line", "rect", "rect_width", "text")\n        names = ("draw_{0}".format(name) for name in methods)\n        instructions = dict((name, getattr(renderer, name)) for name in names)\n        instructions["draw_fill"] = renderer.fill\n        self.instructions = instructions\n\n        if self.showing:\n            self.show()\n\n    def create(self, *args, **kwargs):\n        kwargs["sdl_window"] = self.instance_name\n        instance = super(SDL_Window, self).create(*args, **kwargs)\n        if hasattr(instance, "draw_texture"):\n            instance_name = instance.instance_name\n            if getattr(instance, "pack_on_init", False):#instance.pack_on_init:\n                instance.pack()\n            draw_instruction = Instruction(instance_name, "draw_texture")\n            draw_instruction.priority = .05 # draw after being packed\n            draw_instruction.component = instance\n            draw_instruction.execute()\n        return instance\n\n    def run(self):\n        renderer = self.renderer\n        heappop = heapq.heappop\n        instructions = self.instructions\n        draw_queue = self.draw_queue\n\n        while draw_queue:\n            layer, entry_no, instruction, item = heappop(draw_queue)\n            method, args, kwargs = instruction\n            result = instructions[method](*args, **kwargs)\n            if result:\n                texture, rect = result\n                renderer.copy(texture, None, rect)\n\n        self.queue_counter = 0\n        self.running = False\n        renderer.present()\n\n    def draw(self, item, mode, area, z, *args, **kwargs):\n        self.user_input._update_coordinates(item, area, z)\n        entry = (z, self.queue_counter, ("draw_{0}".format(mode), args, kwargs), item)\n        heapq.heappush(self.draw_queue, entry)\n        self.queue_counter += 1\n        if not self.running:\n            self.running = True\n            Instruction(self.instance_name, "run").execute()\n\n    def get_mouse_state(self):\n        mouse = sdl2.mouse\n        x = ctypes.c_long(0)\n        y = ctypes.c_long(0)\n        buttons = mouse.SDL_GetMouseState(ctypes.byref(x), ctypes.byref(y))\n\n        states = ("BUTTON_LMASK", "BUTTON_RMASK", "BUTTON_MMASK", "BUTTON_X1MASK", "BUTTON_X2MASK")\n        states = (getattr(mouse, "SDL_{0}".format(state)) for state in states)\n        button_state = map(lambda mask: buttons & mask, states)\n        return ((x, y), button_state)\n\n    def get_mouse_position(self):\n        return self.get_mouse_state()[0]\n\n\n"""class Font(SDL_Component):\n\n    defaults = defaults.Font\n\n    def __init__(self, **kwargs):\n        super(Font, self).__init__(**kwargs)\n        self.wraps(font_module.TTF_OpenFont(self.font_path, self.size))"""\n\n\nclass User_Input(vmlibrary.Process):\n\n    defaults = defaults.Process.copy()\n    coordinate_tracker = {None : ((0, 0, 0, 0), 0)}\n\n    def __init__(self, **kwargs):\n        self.active_item = None\n        self.popups = []\n        super(User_Input, self).__init__(**kwargs)\n        self.uppercase_modifiers = (sdl2.KMOD_SHIFT, sdl2.KMOD_CAPS,\n                                    sdl2.KMOD_LSHIFT, sdl2.KMOD_RSHIFT)\n        uppercase = self.uppercase = {\'1\' : \'!\',\n                                      \'2\' : \'@\',\n                                      \'3\' : \'#\',\n                                      \'4\' : \'$\',\n                                      \'5\' : \'%\',\n                                      \'6\' : \'^\',\n                                      \'7\' : \'&\',\n                                      \'8\' : \'*\',\n                                      \'9\' : \'(\',\n                                      \'0\' : \')\',\n                                      ";" : \':\',\n                                      \'\\\'\' : \'"\',\n                                      \'[\' : \']\',\n                                      \',\' : \'<\',\n                                      \'.\' : \'>\',\n                                      \'/\' : "?",\n                                      \'-\' : "_",\n                                      \'=\' : "+",\n                                      \'\\\\\' : "|",\n                                      \'`\' : "~"}\n        letters = string.ascii_letters\n        for index, character in enumerate(letters[:26]):\n            uppercase[character] = letters[index+26]\n\n        # for not yet implemented features\n        unhandled = self.handle_unhandled_instruction\n\n        self.instruction_mapping = {sdl2.SDL_DOLLARGESTURE : unhandled,\n                              sdl2.SDL_DROPFILE : unhandled,\n                              sdl2.SDL_FINGERMOTION : unhandled,\n                              sdl2.SDL_FINGERDOWN : unhandled,\n                              sdl2.SDL_FINGERUP : unhandled,\n                              sdl2.SDL_FINGERMOTION :unhandled,\n                              sdl2.SDL_KEYDOWN : self.handle_keydown,\n                              sdl2.SDL_KEYUP : self.handle_keyup,\n                              sdl2.SDL_JOYAXISMOTION : unhandled,\n                              sdl2.SDL_JOYBALLMOTION : unhandled,\n                              sdl2.SDL_JOYHATMOTION : unhandled,\n                              sdl2.SDL_JOYBUTTONDOWN : unhandled,\n                              sdl2.SDL_JOYBUTTONUP : unhandled,\n                              sdl2.SDL_MOUSEMOTION : self.handle_mousemotion,\n                              sdl2.SDL_MOUSEBUTTONDOWN : self.handle_mousebuttondown,\n                              sdl2.SDL_MOUSEBUTTONUP : self.handle_mousebuttonup,\n                              sdl2.SDL_MOUSEWHEEL : self.handle_mousewheel,\n                              sdl2.SDL_MULTIGESTURE : unhandled,\n                              sdl2.SDL_QUIT : self.handle_quit,\n                              sdl2.SDL_SYSWMEVENT : unhandled,\n                              sdl2.SDL_TEXTEDITING : unhandled,\n                              sdl2.SDL_TEXTINPUT : unhandled,\n                              sdl2.SDL_USEREVENT : unhandled,\n                              sdl2.SDL_WINDOWEVENT : unhandled}\n\n    def run(self):\n        instructions = sdl2.ext.get_instructions()\n        for instruction in instructions:\n            self.instruction_mapping[instruction.type](instruction)\n        self.process("run")\n\n    def _update_coordinates(self, item, area, z):\n        User_Input.coordinate_tracker[item] = (area, z)\n\n    def mouse_is_inside(self, area, mouse_pos_x, mouse_pos_y):\n        x, y, w, h = area\n        if mouse_pos_x >= x and mouse_pos_x <= x + w:\n            if mouse_pos_y >= y and mouse_pos_y <= y + h:\n                return True\n\n    def handle_unhandled_instruction(self, instruction):\n        self.alert("{0} passed unhandled", [instruction.type], \'vv\')\n\n    def handle_quit(self, instruction):\n        sys.exit()\n\n    def handle_mousebuttondown(self, instruction):\n        mouse = instruction.button\n        mouse_x = mouse.x\n        mouse_y = mouse.y\n        check = self.mouse_is_inside\n        possible = []\n        for item, coords in self.coordinate_tracker.items():\n            area, z = coords\n            if check(area, mouse_x, mouse_y):\n                possible.append((item, area, z))\n        try:\n            instance, area, z = sorted(possible, key=itemgetter(2))[-1]\n        except IndexError:\n            self.alert("IndexError on mouse button down (No window objects under mouse)", level="v")\n        else:\n            self.active_item = instance\n            Instruction(instance, "press", mouse).execute()\n\n    def handle_mousebuttonup(self, instruction):\n        mouse = instruction.button\n        area, z = self.coordinate_tracker[self.active_item]\n        if self.mouse_is_inside(area, mouse.x, mouse.y):\n            Instruction(self.active_item, "release", mouse).execute()\n        self.active_item = None\n\n    def handle_mousewheel(self, instruction):\n        wheel = instruction.wheel\n        Instruction(self.active_item, "mousewheel", wheel.x, wheel.y).execute()\n\n    def handle_mousemotion(self, instruction):\n        motion = instruction.motion\n        if self.active_item:\n            x_change = motion.xrel\n            y_change = motion.yrel\n            Instruction(self.active_item, "mousemotion", x_change, y_change).execute()\n        if self.popups:\n            popups = self.popups\n            for item in popups:\n                if not self.mouse_is_inside(item.area, motion.x, motion.y):\n                    Instruction(item.parent.instance_name, "draw_texture").execute()\n                    popups.remove(item)\n                    item.delete()\n\n    def handle_keydown(self, instruction):\n        try:\n            key = chr(instruction.key.keysym.sym)\n        except ValueError:\n            return # key was a modifier key\n        else:\n            if key == "\\r":\n                key = "\\n"\n            modifier = instruction.key.keysym.mod\n            if modifier:\n                if modifier in self.uppercase_modifiers:\n                    try:\n                        key = self.uppercase[key]\n                    except KeyError:\n                        pass\n                    raise NotImplementedError\n                    #stdin.write(key)\n                else:\n                    hotkey = self.get_hotkey(self.active_item, (key, modifier))\n                    if hotkey:\n                        hotkey.execute()\n            else:\n                raise NotImplementedError\n                #stdin.write(key)\n            #sys.stdout.write(key)\n\n    def get_hotkey(self, instance, key_press):\n        try:\n            hotkey = instance.hotkeys.get(key_press)\n            if not hotkey:\n                hotkey = self.get_hotkey(instance.parent, key_press)\n        except AttributeError:\n            hotkey = None\n        return hotkey\n\n    def handle_keyup(self, instruction):\n        pass\n\n    def add_popup(self, item):\n        self.popups.append(item)\n\n\nclass Renderer(SDL_Component):\n\n    defaults = defaults.Renderer\n\n    def __init__(self, **kwargs):\n        self.font_cache = {}\n        kwargs["wrapped_object"] = sdl2.ext.Renderer(kwargs["window"])\n        super(Renderer, self).__init__(**kwargs)\n\n        self.sprite_factory = self.create(Sprite_Factory, renderer=self)\n        self.font_manager = self.create(Font_Manager)\n\n    def draw_text(self, text, rect, **kwargs):\n        cache = self.font_cache\n        if text in cache:\n            results = cache[text]\n        else:\n            call = self.sprite_factory.from_text\n            results = (call(text, fontmanager=self.font_manager, **kwargs), rect)\n            if len(text) <= 3:\n                cache[text] = results\n        return results\n\n    def draw_rect_width(self, area, **kwargs):\n        width = kwargs.pop("width")\n        x, y, w, h = area\n        draw_rect = self.draw_rect\n        print "drawing rect of width", width\n        for rect_size in xrange(1, width + 1):\n            new_x = x + rect_size\n            new_y = y + rect_size\n            new_w = w - rect_size\n            new_h = h - rect_size\n            draw_rect((new_x, new_y, new_w, new_h), **kwargs)\n\n\nclass Sprite_Factory(SDL_Component):\n\n    defaults = defaults.Sprite_Factory\n\n    def __init__(self, **kwargs):\n        kwargs["wrapped_object"] = sdl2.ext.SpriteFactory(renderer=kwargs["renderer"])\n        super(Sprite_Factory, self).__init__(**kwargs)\n\n\nclass Font_Manager(SDL_Component):\n\n    defaults = defaults.Font_Manager\n\n    def __init__(self, **kwargs):\n        _defaults = self.defaults\n        options = {"font_path" : _defaults["font_path"],\n                   "size" : _defaults["default_font_size"],\n                   "color" : _defaults["default_color"],\n                   "bg_color" : _defaults["default_background"]}\n        kwargs["wrapped_object"] = sdl2.ext.FontManager(**options)\n        super(Font_Manager, self).__init__(**kwargs)\n'
tp47
a(Vsdltest.py
S'import mpre.base as base \nInstruction = base.Instruction\n\nif __name__ == "__main__":\n    Instruction("Machine", "create", "sdllibrary.SDL_Window").execute()\n    Instruction("System", "create", "metapython.Shell").execute()\n    Instruction("SDL_Window", "create", "guilibrary.Organizer").execute()\n    Instruction("SDL_Window", "create", "widgetlibrary.Homescreen").execute()'
tp48
a(Vwidgetlibrary.py
S'import time\n\nimport guilibrary\nimport defaults\nimport mpre.base as base\nInstruction = base.Instruction\n\n\nclass Popup_Menu(guilibrary.Container):\n\n    defaults = defaults.Popup_Menu\n\n    def __init__(self, **kwargs):\n        super(Popup_Menu, self).__init__(**kwargs)\n        Instruction("User_Input", "add_popup", self).execute()\n\n\nclass Homescreen(guilibrary.Window):\n\n    defaults = defaults.Homescreen\n\n    def __init__(self, **kwargs):\n        super(Homescreen, self).__init__(**kwargs)\n        self.create(Task_Bar)\n\n\nclass Task_Bar(guilibrary.Container):\n\n    defaults = defaults.Task_Bar\n\n    def __init__(self, **kwargs):\n        super(Task_Bar, self).__init__(**kwargs)\n        self.create(Date_Time_Button)\n\n\nclass Date_Time_Button(guilibrary.Button):\n\n    defaults = defaults.Date_Time_Button\n\n    def __init__(self, **kwargs):\n        super(Date_Time_Button, self).__init__(**kwargs)\n        self.update_time()\n\n    def update_time(self):\n        self.text = time.asctime()\n        instance_name = self.instance_name\n        updater = Instruction(instance_name, "update_time")\n        updater.priority = 1\n        updater.component = self\n        updater.execute()\n        Instruction(instance_name, "draw_texture").execute()\n\n\nclass Right_Click_Menu(Popup_Menu):\n\n    defaults = defaults.Right_Click_Menu\n\n    def __init__(self, **kwargs):\n        super(Right_Click_Menu, self).__init__(**kwargs)\n        types = ("builtins", "private", "methods", "properties", "attributes")\n        attributes = dict((name, []) for name in types)\n        target = self.target\n        for attribute in dir(target):\n            if "__" in attribute:\n                attributes["builtins"].append(attribute)\n            elif "_" == attribute[0]:\n                attributes["private"].append(attribute)\n            elif callable(getattr(target, attribute)):\n                attributes["methods"].append(attribute)\n            elif type(getattr(target, attribute)) is property:\n                attributes["properties"].append(attribute)\n            else:\n                attributes["attributes"].append(attribute)\n        for name, collection in attributes.items():\n            self.create(Right_Click_Button, text=name, attributes=collection, size=(50, 50))\n\n\nclass Right_Click_Button(guilibrary.Button):\n\n    defaults = defaults.Right_Click_Button\n\n    def __init__(self, **kwargs):\n        super(Right_Click_Button, self).__init__(**kwargs)\n\n    def click(self, mouse):\n        self.create(Attribute_Displayer, attributes=self.attributes)\n\n\nclass Attribute_Displayer(guilibrary.Window): pass\n'
tp49
asVmisc
p50
(lp51
(Vcompresstest.py
S'def convert(old_value, old_base, new_base):\n    """convert a value from one base another. base should be a list of length\n    base containing the unique characters to be used to represent each value in\n    the system. value should be a string representation of the value. new_base\n    is the desired base you want the value in."""\n\n    old_base_size = len(old_base)\n    decimal_value = 0\n    new_base_size = len(new_base)\n    new_value = []\n\n    for power, value_representation in enumerate(reversed(old_value)):\n        # this is the decimal value of the _value character from the old system\n        #print "looking for %s in %s" % (value_representation, old_base)\n        _value = old_base.index(value_representation)\n        #print "decimal value is: ", _value\n        # the decimal value of the value at this place value in the old system\n        result = _value*(old_base_size**power)\n        # add the piece to the rest of the number\n        #print "cumulative before: ", decimal_value\n        decimal_value += result\n        #print "cumulative after: ", decimal_value\n\n    while decimal_value >= 1:\n        decimal_value, digit = divmod(decimal_value, new_base_size)\n        digit = new_base[digit]\n        new_value.append(digit)\n\n    new_value = \'\'.join(str(item) for item in reversed(new_value))\n\n    return new_value\n  \ndef interpret(bit_string):\n    new = convert(bit_string, base_256, base_2)\n    bits = len(new)\n    print bits, divmod(bits, 8)\n    return new\n\n    \nif __name__ == "__main__":\n    base_256 = \'\'.join(str(x) for x in xrange(256))\n    base_2 = \'\'.join(str(x) for x in xrange(2))\n    base_1 = \'0\'\n    test_bits = "00000001"\n    b2to1 = convert(test_bits, base_2, base_1)\n    print b2to1, len(b2to1)\n  #  for x in xrange(4):\n   #     test_bits = interpret(test_bits)\n        \n    #print "{} bits went in, {} bits came out".format(8, len(test_bits))'
tp52
a(Vconvert_bases.py
S'import string, sys, os\nfrom random import randint\n\nBASE_2 = ["0", "1"]\nBASE_8 = string.octdigits\nBASE_10 = string.digits\nBASE_16 = string.hexdigits\nBASE_256 = [chr(x) for x in xrange(256)]\nALPHABET = string.ascii_letters+" " # WARNING! combining lowercase+uppercase will break things\nLOWERCASE_ALPHABET = string.ascii_lowercase+" "\nUPPERCASE_ALPHABET = string.ascii_uppercase+" "\nSYMBOLS = "!@#$%^&*()_+=-{}[]|\\\\:;\\\'\\"<,>.?/`~ "\nRALPHABET = \' ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba\'\nRSYMBOLS = " ~`/?.>,<\\"\\\';:\\\\|][}[-=+_)(*&^%$#@!"\nRBASE_10 = "9876543210"\nRLOWERCASE_ALPHABET = "zyxwvutsrqponmlkjihgfedcba"\nKEYBOARD = ALPHABET+SYMBOLS+BASE_10\n\n\nclass Number_Base(object):\n\n    def __init__(self, base=(\'0\', \'1\')):\n        super(Number_Base, self).__init__()\n        self.base = base\n        self.base_size = len(base)\n\n    def convert_from(self, old_value, old_base):\n        """convert a value from one base another. base should be a list of length\n        base containing the unique characters to be used to represent each value in\n        the system. value should be a string representation of the value. new_base\n        is the desired base you want the value in."""\n        old_base_size = len(old_base)\n        decimal_value = 0\n        new_base = self.base\n        new_base_size = self.base_size\n        new_base_chunk_size = len(new_base[-1])\n        new_value = []\n\n        for power, value_representation in enumerate(reversed(old_value)):\n            # this is the decimal value of the _value character from the old system\n            #print "looking for %s in %s" % (value_representation, old_base)\n            _value = old_base.index(value_representation)\n            #print "decimal value is: ", _value\n            # the decimal value of the value at this place value in the old system\n            result = _value*(old_base_size**power)\n            # add the piece to the rest of the number\n            #print "cumulative before: ", decimal_value\n            decimal_value += result\n            #print "cumulative after: ", decimal_value\n\n        while decimal_value > 0: # divmod = divide and modulo in one action\n            old_value = decimal_value\n            decimal_value, digit = divmod(decimal_value, new_base_size)\n            digit = new_base[digit]\n            new_value.append(digit)\n\n        new_value = [str(item) for item in reversed(new_value)]\n\n        return \'\'.join(new_value)\n\ndef convert(old_value, old_base, new_base):\n    """convert a value from one base another. base should be a list of length\n    base containing the unique characters to be used to represent each value in\n    the system. value should be a string representation of the value. new_base\n    is the desired base you want the value in."""\n\n    old_base_size = len(old_base)\n    decimal_value = 0\n    new_base_size = len(new_base)\n    new_base_chunk_size = len(new_base[-1])\n    new_value = []\n\n    for power, value_representation in enumerate(reversed(old_value)):\n        # this is the decimal value of the _value character from the old system\n        #print "looking for %s in %s" % (value_representation, old_base)\n        _value = old_base.index(value_representation)\n        #print "decimal value is: ", _value\n        # the decimal value of the value at this place value in the old system\n        result = _value*(old_base_size**power)\n        # add the piece to the rest of the number\n        #print "cumulative before: ", decimal_value\n        decimal_value += result\n        #print "cumulative after: ", decimal_value\n\n    while decimal_value >0: # divmod = divide and modulo in one action\n        old_value = decimal_value\n        decimal_value, digit = divmod(decimal_value, new_base_size)\n        digit = new_base[digit]\n        new_value.append(digit)\n\n    new_value = \'\'.join(str(item) for item in reversed(new_value))\n\n    return new_value\n\n\ndef interpret_as(value, new_base):\n    new_base_size = len(new_base)\n    new_value = 0\n    for power, number in enumerate(reversed(str(value))):\n        new_value += int(number) * (new_base_size ** power)\n    return new_value\n\ndef find_factors(value, old_base=BASE_16):\n    series = []\n    value_representation = str(value)\n    for x in xrange(1, 256):\n        new_base = \'\'.join(chr(y) for y in xrange(0, x+1))\n        #print "converting to base {0}".format(new_base)\n        new_number = convert(value_representation, old_base, new_base)\n        binary_characters = zero, one = new_base[0], new_base[1]\n        print "checking if {0} and {1} are in {2} (base {3})".format(zero, one, new_number, len(new_base))\n        for character in new_number:\n            if character not in binary_characters:\n                break\n            series.append(new_number)\n    return \'\\n\'.join(series)\n\n\nif __name__ == "__main__":\n    bits = "1111 1111".replace(\' \', \'\') * 4\n    bit_length = len(bits)\n    decimal = interpret_as(bits, BASE_256)\n    new_bits = format(decimal, \'b\')\n    new_bit_length = len(new_bits)\n    difference = new_bit_length - bit_length\n\n    format_args = (bit_length, bits, decimal, new_bits, new_bit_length, difference)\n    #print "From the {0} bits {1}, the number {2} was generated, which itself in binary is {3}  and uses {4} bits. Size difference: {5}".format(*format_args)\n\n    series = find_factors(decimal, BASE_10)\n    print "found series", series\n#    base_ten = Number_Base(BASE_10)\n #   original = \'\'.join(str(randint(0, 1)) for x in xrange(16))\n  #  new = base_ten.convert_from(original, BASE_2)\n   # print new\n\n    """new = convert(original, BASE_2, BASE_256)\n    count = 1\n    while new[-1] != BASE_256[0]:\n        count +=1\n        print "({0} tries) looking for a factor...".format(count)\n        original = \'\'.join(str(randint(0, 1)) for x in xrange(2048))\n        new = convert(original, BASE_2, BASE_256)\n\n    print "{0} is a factor of 256!".format(new)\n    restored = convert(new, BASE_256, BASE_10)\n    print restored, int(restored) % 256"""\n'
tp53
a(Vdecoratorlibrary.py
S'#   mpf.decoratorlibrary - decorators particularly useful with the runtime decorator\n#\n#    Copyright (C) 2014  Ella Rose\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport trace\nimport time\nimport inspect\nimport StringIO\nfrom test import pystone\nfrom functools import wraps\nfrom weakref import ref\n\nif "win" in sys.platform:\n    timer = time.clock\nelse:\n    timer = time.time\n\nclass Pystone_Test(object):\n\n    def __init__(self, function):\n        self.function = function\n        if not hasattr(Pystone_Test, "pystones_per_second"):\n            Pystone_Test.pystones_per_second = pystone.pystones(pystone.LOOPS)\n\n    def __call__(self, *args, **kwargs):\n        pystones_per_second = Pystone_Test.pystones_per_second\n        if sys.platform == "win32":\n            timer = time.clock\n        else:\n            timer = time.time\n        start_time = timer()\n        try:\n            result = self.function(*args, **kwargs)\n        except:\n            end_time = timer()\n            time_taken = end_time-start_time\n            pystones_result = time_taken/pystones_per_second\n            print "%s crashed after %s pystones of work" % (self.function, pystones_result)\n            print "local variables: ", locals(), "\\n"\n            raise\n        else:\n            end_time = timer()\n            time_taken = end_time-start_time\n            pystones_result = time_taken/pystones_per_second\n            print "%s took %s pystones to perform" % (self.function, pystones_result)\n            return result\n\n\nclass Timed(object):\n\n    def __init__(self, function):\n        self.function = function\n        \n    def __call__(self, *args, **kwargs):\n        start = timer()\n        self.result = self.function(*args, **kwargs)\n        return timer() - start\n\nclass Tracer(object):\n\n    def __init__(self, function):\n        self.function = function\n        self.source = \'\'\n        self.debug = \'\'\n        self.print_mode = "source"\n        self.function_source = \'\'\n\n    def get_frame_info(self, frame):\n        code = frame.f_code\n        call_info = {"code" : code,\n                     "function_name" : code.co_name,\n                     "line_number" : frame.f_lineno,\n                     "called_from" : code.co_filename}\n\n        module = code.co_filename.split("\\\\")[-1].replace(".py", "")\n        source_info = {"function" : inspect.getsource(code),\n                       "module" : inspect.getsource(__import__(module))}\n\n        caller = frame.f_back\n        if caller:\n            caller_code = caller.f_code\n            caller_info = {"caller" : caller,\n                           "code" : caller_code,\n                           "line_number" : caller.f_lineno,\n                           "function_name" : caller_code.co_name}\n            source_info["caller"] = inspect.getsource(caller_code)\n        else:\n            caller_info = {}\n\n        return call_info, caller_info, source_info\n\n    def trace(self, frame, instruction, arg):\n        if instruction != "exception":\n            call_info, caller_info, source_info = self.get_frame_info(frame)\n            local_trace = None\n            function_name = call_info["function_name"]\n            frame_locals = frame.f_locals\n            if call_info["function_name"] == "write":\n                pass # ignore print calls\n            elif instruction == "return":\n                self.source += "returned %s\\n" % type(arg)\n                self.debug += "%s returned %s\\n" % (function_name, arg)\n            else:\n                source = source_info["module"].split("\\n")[call_info["line_number"]]\n\n                for attribute, value in frame_locals.items():\n                    source = source.replace(attribute, str(value))\n                print source\n                #self.source += source\n                #self.debug += "call to %s from %s line %s\\n" % \\\n                #(function_name, call_info["called_from"], call_info["line_number"])\n                local_trace = self.trace\n            return local_trace\n\n    def __call__(self, *args, **kwargs):\n        old_trace = sys.gettrace()\n        sys.settrace(self.trace)\n        results = self.function(*args, **kwargs)\n        sys.settrace(old_trace)\n        if "debug" in self.print_mode:\n            print self.debug\n        if "source" in self.print_mode:\n            print self.source\n        return results\n\n\nclass Dump_Source(Tracer):\n    """Tracer decorator that dumps source code to disk instead of writing to sys.stdout."""\n\n    def __init__(self, function):\n        super(Dump_Source, self).__init__(function)\n\n    def __call__(self, *args, **kwargs):\n        old_stdout = sys.stdout\n        with open("%s_source.txt" % self.function.func_name, "w") as file:\n            sys.stdout = file\n            super(Dump_Source, self).__call__(*args, **kwargs)\n            sys.stdout = old_stdout\n            file.close()\n\n\nclass Log_Arguments(object):\n\n    def __init__(self, function):\n        self.function = function\n\n    def __call__(self, *args, **kwargs):\n        print "\\calling %s with args: %s and kwargs: %s" % (self.function, args, kwargs)\n        return self.function(*args, **kwargs)\n \n'
tp54
a(Vdecoratorlibrary2.py
S'regular_template =\\\n"""def __call__({0}):\n    if monkey_patch or decorator or decorators:\n        modifier = [mod for mod in (monkey_patch, decorator, decorators) if mod][0]\n        call = self.handler_map[modifier](locals()[modifier])\n    else:\n        call = self.function\n    return """\n    \nvarargs_template =\\\n"""def __call__({0}):\n    check_for = kwargs.pop\n    modifiers = ("monkey_patch", "decorator", "decorators")\n    for modifier in modifiers:\n        found = check_for(modifier, None)\n        if found:\n            call = self.handler_map[modifier](found)\n            break\n    else:\n        call = self.function\n    return """        \n    \ncall_template = "call({})"\n\n"""self.handler_map = {"monkey_patch" : self._handle_monkey_patch,\n                            "decorator" : self._handle_decorator,\n                            "decorators" : self._handle_decorators}"""\n                            \nclass Decorator(object):\n        \n    def __init__(self, function):\n\n        \n        if default_args:\n            new_args = []\n            for arg in default_args:\n                if isinstance(arg, str):\n                    new_arg = repr(arg)\n                else:\n                    new_arg = arg\n                new_args.append(new_arg)\n            default_args = new_args\n            non_defaults = len(args) - len(default_args)\n            len(default_args)\n            header_args = header_args[:non_defaults] + ["{}={}".format(arg_name, default_args[index]) for index, arg_name in enumerate(header_args[non_defaults:])]\n            \n        if varargs:\n            header_size += "{}, "\n            header_args.append("*"+varargs)\n            template = self.varargs_template        \n        \n        if keyword_args:\n            header_size += "{}, "\n            header_args.append("**" + keyword_args)\n            call_size += "{}, "\n            call_args.append("**" + keyword_args)\n            \n        else:\n            header_size += "{}, " * 3\n            header_args.extend(("monkey_patch=None", "decorator=None", "decorators=None"))        \n            \n        ending = header_size.rfind(", ")\n        header_size = header_size[:ending]\n        \n        ending = call_size.rfind(", ")\n        call_size = call_size[:ending]\n        \n        self.header_size = header_size\n        self.header_args = header_args\n     #   print header_size, header_args\n      #  print "header: {}".format(header_size).format(*header_args)\n       # print "call sig: {}".format(call_size).format(*call_args)\n        template = template.format(header_size).format(*header_args)\n        template = template.replace("self.function.im_self", "self", 1)\n        \n        call_template = self.call_template.format(call_size).format(*call_args)\n        \n        ready_template = self.template = template + call_template\n        new_code = compile(ready_template, "compiled", \'exec\')\n\n        results = {}\n        exec new_code in locals(), results\n        self.__call__  = results.pop("__call__")\n        \n        #print self, "__call__ is ", self.__call__()\n        print "created custom call signature for", function.func_name\n        if function.func_name == "attribute_setter":\n            print call_args, call_size\n            print call_template\n            print inspect.getargspec(self.__call__)\n            print ready_template\n     \n    def __call__(self):\n        raise NotImplementedError\n\n    def _handle_context_manager(self, args, kwargs):\n        module_name, context_manager_name = self._resolve_string(kwargs.pop("context_manager"))\n        module = self._get_module(module_name)\n        context_manager = getattr(module, context_manager_name)\n        with context_manager():\n            result = self.function(*args, **kwargs)\n        return result\n\n    def _handle_monkey_patch(self, patch_info):\n        module_name, patch_name = self._resolve_string(patch_info)\n        module = self._get_module(module_name)\n        monkey_patch = getattr(module, patch_name)\n        try:\n            result = functools.partial(monkey_patch, self.function.im_self)\n        except AttributeError: # function has no attribute im_self (not a method)\n            result = monkey_patch\n        return result\n\n    def _handle_decorator(self, decorator_type):\n        module_name, decorator_name = self._resolve_string(decorator_type)\n        decorator = self._get_decorator(decorator_name, module_name)\n        return decorator(self.function)\n\n    def _handle_decorators(self, decorator_names):\n        decorators = []\n        for item in decorator_names:\n            module_name, decorator_name = self._resolve_string(item)\n            decorator = self._get_decorator(decorator_name, module_name)\n            decorators.append(decorator)\n\n        wrapped_function = self.function\n        for item in reversed(decorators):\n            wrapped_function = item(wrapped_function)\n        return wrapped_function\n\n    def _resolve_string(self, string):\n        try: # attempt to split the string into a module and attribute\n            module_name, decorator_name = string.split(".")\n        except ValueError: # there was no ".", it\'s just a single attribute\n            module_name = "__main__"\n            decorator_name = string\n        finally:\n            return module_name, decorator_name\n\n    def _get_module(self, module_name):\n        try: # attempt to load the module if it exists already\n            module = sys.modules[module_name]\n        except KeyError: # import it if it doesn\'t\n            module = __import__(module_name)\n        finally:\n            return module\n\n    def _get_decorator(self, decorator_name, module_name):\n        module = self._get_module(module_name)\n        return getattr(module, decorator_name)\n        \n"""        args, varargs, keyword_args, default_args = inspect.getargspec(function)\n        \n        args[0] = "self.function.im_self"\n        template = self.regular_template\n        header_size = "{}, " * len(args)\n        header_args = [arg for arg in args]\n        call_args = copy(header_args)\n        call_size = header_size\n        \n        if default_args:\n            new_args = []\n            for arg in default_args:\n                if isinstance(arg, str):\n                    new_arg = repr(arg)\n                else:\n                    new_arg = arg\n                new_args.append(new_arg)\n            default_args = new_args\n            non_defaults = len(args) - len(default_args)\n            len(default_args)\n            header_args = header_args[:non_defaults] + ["{}={}".format(arg_name, default_args[index]) for index, arg_name in enumerate(header_args[non_defaults:])]\n            \n        if varargs:\n            header_size += "{}, "\n            header_args.append("*"+varargs)\n            template = self.varargs_template        \n        \n        if keyword_args:\n            header_size += "{}, "\n            header_args.append("**" + keyword_args)\n            #print "increasing call size by 1", call_size\n            call_size += "{}, "\n           # print "call size is now", call_size\n            call_args.append("**" + keyword_args)\n            \n        else:\n            header_size += "{}, " * 3\n            header_args.extend(("monkey_patch=None", "decorator=None", "decorators=None"))        \n            \n        ending = header_size.rfind(", ")\n        header_size = header_size[:ending]\n        \n        ending = call_size.rfind(", ")\n        call_size = call_size[:ending]\n        \n        self.header_size = header_size\n        self.header_args = header_args\n     #   print header_size, header_args\n      #  print "header: {}".format(header_size).format(*header_args)\n       # print "call sig: {}".format(call_size).format(*call_args)\n        template = template.format(header_size).format(*header_args)\n        template = template.replace("self.function.im_self", "self", 1)\n        \n        call_template = self.call_template.format(call_size).format(*call_args)\n        \n        ready_template = self.template = template + call_template\n        new_code = compile(ready_template, "Runtime_Decorator.__call__ compile", \'exec\')\n\n        results = {}\n        exec new_code in locals(), results\n        self.__call__  = results.pop("__call__")\n        \n        #print self, "__call__ is ", self.__call__()\n        print "created custom call signature for", function.func_name\n        if function.func_name == "attribute_setter":\n            print call_args, call_size\n            print call_template\n            print inspect.getargspec(self.__call__)\n            print ready_template\n     \n    def __call__(self):\n        raise NotImplementedError"""        '
tp55
a(Vdialectlibrary.py
S'import pickle\nimport tokenize\nimport string\nimport sys\nimport pydoc\nfrom StringIO import StringIO\nfrom random import randint\nfrom keyword import kwlist as keywords\n\n"""\n    dialect = dict((keyword, keyword) for keyword in keywords)\n\nThe above programmatically populates a dictionary using CPythons keywords. The\nfollowing dictionary would be equivalent:\n\n    dialect = {"and" : "and",\n               "as" : "as",\n               "assert" : "assert",\n               "break" : "break",\n               "class" : "class",\n               ... and so on\n\nYou may redefine any keyword by reassigning it\'s value in this dictionary\nSome examples:\n\n    dialect["def"] = "define a function", # a more verbose syntax\n    dialect["yield"] = "return and continue", # an alternative syntax\n    dialect["with"] = "@c#*(&DI9" # an obfuscated syntax\n\nAny word in the dictionary can either be modified manually or automatically.\nIf done automatically, the default mode will not transpose any token names. This can\nbe changed to produce a random unique per name token name.\n"""\n\nDICTIONARY = dict((keyword, keyword) for keyword in keywords)\ncharacters = [\'\\t\', ":", \',\', \'.\', "(", ")", "\\n", "#", "=", "+", "-", "*", "&", "%", "!", \'[\', \']\', \'{\', \'}\', \'"\', "\'", "\\\\", \'/\', "\'\'\'", \'"""\', \'<\', \'>\']\nfor x in xrange(10):\n    characters.append(chr(x))\nfor character in characters:\n    DICTIONARY[character] = character\nDICTIONARY[""] = ""\n\nfor module_name in sys.builtin_module_names:\n    DICTIONARY[module_name] = module_name\n\n\n\n\nclass Module_Listing(object):\n\n    def __init__(self, **kwargs):\n        super(Module_Listing, self).__init__()\n        [setattr(self, key, value) for key, value in kwargs.items()]\n        setattr(self, "file", getattr(self, "file", StringIO()))\n\n    def from_help(self):\n        helper = pydoc.Helper(output=self.file)\n        helper("modules")\n\n    def read_file(self):\n        file = self.file\n        file.seek(0)\n        text = file.read()\n        return text\n\n    def trim(self, text):\n        _file = StringIO(text)\n        found = []\n        count = 0\n        for line in _file.readlines():\n            if line.split(" ").count("") > 2:\n                found += line.split()\n\n        return \' \'.join(found)\n\n    def get_modules(self):\n        self.from_help()\n        original = self.read_file()\n        return self.trim(original)\n\n    def make_file(self, filename):\n        with open(filename, \'w\') as _file:\n            _file.write(self.get_modules())\n            _file.flush()\n            _file.close()\n\n\nclass Dialect(object):\n\n    def __init__(self, **kwargs):\n        self.dictionary = kwargs\n\n    def translate(self, _file):\n        tokens = []\n        token_generator = tokenize.generate_tokens(_file.readline)\n        dictionary = self.dictionary\n\n        for token_type, token_name, starts_at, ends_at, full_line in token_generator:\n            if token_name in dictionary:\n                token_name = dictionary[token_name]\n            tokens.append((token_type, token_name, starts_at, ends_at, full_line))\n        return tokenize.untokenize(tokens)\n\n    def translate_from(self, _file):\n        reverse_dictionary = dict((value, key) for key, value in self.dictionary.items())\n        source = _file.read()\n        for alternative, keyword in reverse_dictionary.items():\n            source = source.replace(alternative, keyword)\n        return source\n\n    def save(self, filename, mode="self"):\n        if mode == "dictionary":\n            target = self.dictionary\n        else:\n            target = self\n        with open(filename, "wb") as _file:\n            _file.write(pickle.dumps(target))\n            _file.flush()\n            _file.close()\n\n\nclass Random_Dialect(Dialect):\n\n    def __init__(self, **kwargs):\n        super(Random_Dialect, self).__init__(**kwargs)\n        self.delimiters = [\'\\t\', ":", \',\', \'.\', "(", ")", "\\n", "#", "=", "+", "-", "*", "&", "%", "!", \'[\', \']\', \'{\', \'}\', \'"\', "\'", "\\\\", \'/\', "\'\'\'", \'"""\', \'<\', \'>\']#characters#(".", ",", "(", ")", ":", "\\n", \'#\', "\'\'\'", \'"""\')\n\n    def random_word(self):\n        letters = string.ascii_letters\n        word = \'\'.join(letters[randint(0, len(letters)-1)] for x in xrange(1, randint(2, 8)))\n        """limit = randint(33, 128)\n        size = randint(2, 10)\n        word = \'\'.join(chr(randint(33, limit)) for x in xrange(randint(2, size)))"""\n        used = self.dictionary.values()\n        while word in used:\n            word = self.random_word()\n        return word\n\n    def translate(self, _file, mode="to"):\n        _file_text = _file.read()\n        dictionary = self.dictionary\n        delimiters = self.delimiters\n        _file_text = _file_text.replace("     ", \'\\t\')\n        if mode == "to":\n            for delimiter in delimiters:\n                _file_text = _file_text.replace(delimiter, " {0} ".format(delimiter))\n\n        elif mode == "from":\n            dictionary = dict((value, key) for key, value in dictionary.items())\n\n        __file = StringIO(_file_text)\n        result = self._translate_file(__file, dictionary)\n        if mode == "from":\n            for delimiter in delimiters:\n                result = result.replace(" {0} ".format(delimiter), delimiter)\n        result = result.replace("\\t", \'     \')\n        return result\n\n    def _translate_file(self, _file, dictionary):\n        new_file = []\n        for line in _file.readlines():\n            new_line = []\n            for word in line.split(" "):\n                new_token = self._translate_word(word, dictionary)\n                new_line.append(new_token)\n            #    print "adding new token {0} from word {1}".format(new_token, word)\n            #print "appending \\n{0}\\n{1}\\n".format(new_line, " ".join(new_line))\n            new_file.append(" ".join(new_line))\n        return "".join(new_file)\n\n    def _translate_word(self, word, dictionary):\n        try:\n            new_token = dictionary[word]\n        except KeyError:\n            try:\n                new_token = dictionary[word] = str(int(word))\n            except ValueError:\n                end = ""\n                if word and "\\n" == word[-1]:\n                    end = "\\n"\n                new_token = dictionary[word] = self.random_word() + end\n        return new_token\n\n\nclass Obfuscated_Dialect(Random_Dialect):\n\n    def __init__(self, **kwargs):\n        super(Obfuscated_Dialect, self).__init__(**kwargs)\n\n    def obfuscate(self, _file, mode="to"):\n        source = super(Obfuscated_Dialect, self).translate(_file, mode)\n        for delimiter in self.delimiters:\n            source = source.replace(" {0} ".format(delimiter), delimiter)\n      #  source = source.replace("\\t", \'     \')\n        return source\n\n\nif __name__ == "__main__":\n    import difflib\n    from verbosedialect import verbose_dialect\n\n    from StringIO import StringIO\n    difference = difflib.Differ()\n    filename = "./network.py"\n    _file = open(filename)\n    source = _file.read()\n    _file.seek(0)\n\n    #print source\n    """translated = verbose_dialect.translate(_file)\n    print translated\n\n    translated_file = StringIO(translated)\n    translated_back = verbose_dialect.translate_from(translated_file)"""\n\n    """translated = c_dialect.translate(_file)\n    translated_flo = StringIO(translated)\n    translated_back = c_dialect.translate_from(translated_flo)\n    print translated"""\n\n    key = Random_Dialect(**DICTIONARY)\n    key.save("key.mpy", mode="dictionary")\n\n    encrypted = key.translate(_file)\n    encrypted_file = open("{0}.mpy".format(filename), "w+")\n    encrypted_file.write(encrypted)\n    encrypted_file.flush()\n    encrypted_file.seek(0)\n    _file.seek(0)\n    print encrypted[:2048]\n    plain_text = key.translate(encrypted_file, "from")\n    print plain_text[:2048]\n    assert plain_text == source\n\n    key2 = Obfuscated_Dialect(**DICTIONARY)\n    obfuscated = key2.obfuscate(_file)\n    obfuscated_file = open("{0}.opy".format(filename), "w+")\n    obfuscated_file.write(obfuscated)\n    obfuscated_file.flush()\n    obfuscated_file.close()\n    print obfuscated\n    code = compile(obfuscated, \'encrypted\', \'exec\')\n   # exec code in locals(), globals()\n    #try:\n\n    #except AssertionError:\n     #   print "Assertion Error"\n      #  diff = difference.compare(source.splitlines(), plain_text.splitlines())\n       # print "\\n".join(diff)\n\n    code = compile(plain_text, "encrypted", "exec")\n    exec code in locals(), globals()\n'
tp56
a(Vscratch.py
S'def import_change(module_name):\n    try:\n        importlib.import_module(module_name)\n    except ImportError:\n        if module_name in rebind_names:\n            return rebind_names[module_name]\n            \nfrom mpre.misc.decoratorlibrary import Timed\n\ndef test(method_names):\n    times = []\n    string = "{: >20} time: {: >20}"\n    for method_name in method_names:\n        time, result = Timed(locals()[method_name])()\n        times.append(string.format(method_name, time))            '
tp57
a(Vsecuritylibrary.py
S'import sys\nimport functools\nfrom multiprocessing import Process\nfrom contextlib import contextmanager\n\nimport mpre.base as base\nimport mpre.defaults as defaults\nimport mpre.vmlibrary as vmlibrary\nfrom mpre.utilities import Latency\nInstruction = base.Instruction\n\nScanner = defaults.Process.copy()\nScanner.update({"subnet" : "127.0.0.1",\n"ports" : (22, ),\n"range" : (0, 0, 0, 254),\n"yield_interval" : 50,\n"scan_size" : 1,\n"timeout" : 0})\n\nDoS = defaults.Process.copy()\nDoS.update({"salvo_size" : 100,\n"count" : 0,\n"ip" : "localhost",\n"port" : 80,\n"target" : None,\n"timeout_notify" : False,\n"display_latency" : False,\n"display_progress" : False})\n\ndef trace_function(frame, instruction, args):\n    pass\n\n@contextmanager\ndef resist_debugging():\n    sys.settrace(trace_function)\n    yield\n    sys.settrace(None)\n\n\nclass DoS(vmlibrary.Process):\n\n    defaults = DoS\n\n    def __init__(self, **kwargs):\n        super(DoS, self).__init__(**kwargs)\n        self.latency = Latency(name="Salvo size: %i" % self.salvo_size)\n        \n        self.options = {"on_connect" : self._on_connection,\n                   "target" : self.target,\n                   "ip" : self.ip,\n                   "port" : self.port,\n                   "timeout_notify" : self.timeout_notify,\n                   "bad_target_verbosity" : \'v\'}\n        \n    def _on_connection(self, connection):\n        connection.delete()\n        \n    def socket_recv(self, connection):\n        connection.recv(8192)\n\n    def run(self):\n        self.count += 1\n        if self.display_progress:\n            print "Launched {0} connections".format(self.count * self.salvo_size)\n        if self.display_latency:\n            latency = self.latency\n            #print "launching salvo: {0} connections per second ({1} connections attempted)".format(self.latency.average.meta_average, (self.count * self.salvo_size))\n            self.latency.update()\n            self.latency.display()\n        options = self.options\n        for connection_number in xrange(self.salvo_size):\n            self.create("network.Outbound_Connection", **options)\n\n        self.run_instruction.execute()\n\n        \nclass Scanner(vmlibrary.Process):\n\n    defaults = Scanner\n\n    def __init__(self, *args, **kwargs):\n        self.threads = []\n        super(Scanner, self).__init__(*args, **kwargs)\n        self.network_buffer = {}\n\n        self.scan_address_alert = functools.partial(self.alert,\n                                                    "Beginning scan of {0}:{1}",\n                                                    level = "vv")\n        self.options = {"socket_recv" : self._socket_recv,\n                        "on_connect" : self._notify,\n                        "timeout" : self.timeout,\n                        "timeout_notify" : False,\n                        "bad_target_verbosity" : \'v\'}\n\n        self.create_threads()\n\n    def create_threads(self):\n        subnet_list = self.subnet.split(".")\n        subnet_zero = int(subnet_list[0])\n        subnet_zero_range = subnet_zero + self.range[0]\n        subnet_one = int(subnet_list[1])\n        subnet_one_range = subnet_one + self.range[1]\n        subnet_two = int(subnet_list[2])\n        subnet_two_range = subnet_two + self.range[2]\n        subnet_three = int(subnet_list[3])\n        subnet_three_range = subnet_three + self.range[3]\n\n        subnet_range = (subnet_zero_range, subnet_one_range,\n                        subnet_two_range, subnet_three_range)\n        subnet_range = \'.\'.join(str(subnet) for subnet in subnet_range)\n        self.subnet_range = (self.subnet, subnet_range)\n\n        ports = self.ports\n        low_port = min(ports)\n        high_port = max(ports)\n        if low_port != high_port:\n            self.port_range = (low_port, high_port)\n        else:\n            self.port_range = low_port\n\n        for field_zero in xrange(subnet_zero, subnet_zero_range + 1):\n            for field_one in xrange(subnet_one, subnet_one_range + 1):\n                for field_two in xrange(subnet_two, subnet_two_range + 1):\n                    for field_three in xrange(subnet_three, subnet_three_range + 1):\n                        address = ".".join((str(field_zero), str(field_one), str(field_two), str(field_three)))\n                        thread = self.scan_address(address, ports)\n                        self.threads.append(thread)\n\n    def run(self):\n        for thread in self.threads[:self.scan_size]:\n            try:\n                next(thread)\n            except StopIteration:\n                self.threads.remove(thread)\n        if not self.threads:\n            self.alert("Finished scanning {0}-{1}", self.subnet_range, \'v\')\n            #Instruction(self.instance_name, "delete").execute()#self.delete()\n        else:\n            self.run_instruction.execute()\n\n    def _notify(self, connection):\n        address = connection.getpeername()\n        self.alert("Found a service at {0}:{1}", address, "v")\n        Instruction("Service_Listing", "add_service", address).execute()\n        connection.delete()\n\n    def _socket_recv(self, connection):\n        self.network_buffer[connection] = connection.recv(2048)\n\n    def scan_address(self, address, ports):\n        options = self.options\n        options["ip"] = address\n        self.scan_address_alert([address, self.port_range])\n        yield_interval = self.yield_interval\n\n        while ports:\n            for port in ports[:yield_interval]:\n                self.create("network.Outbound_Connection", port=port, **options)\n            ports = ports[yield_interval:]\n            yield\n\n# warning: these will crash/freeze your machine\n\nmemory_eater = [\'\'.join(chr(x) for x in xrange(128))]\n\ndef fork_bomb(eat_memory=True):\n    def spawn():\n        return Process(target=fork)\n    while True:\n        spawn().start()\n        if eat_memory:\n            try:\n                memory_eater.extend(x*8 for x in memory_eater)\n            except:\n                pass'
tp58
a(Vverbosedialect.py
S'import dialectlibrary\n\ndialect = dialectlibrary.DICTIONARY.copy()\ndialect["and"] = "and"\ndialect["as"] = "But call it"\ndialect["assert"] = "Make sure that"\ndialect["break"] = "Move on from this loop"\ndialect["class"] = "What is a"\ndialect["continue"] = "Handle the next iteration"\ndialect["def"] = "How does it"\ndialect["del"] = "Decrement the reference counter of"\ndialect["elif"] = "If not and"\ndialect["else"] = "If not then"\ndialect["except"] = "So prepare for the exception(s)"\ndialect["exec"] = "Execute"\ndialect["finally"] = "Ensure this happens"\ndialect["for"] = "For each"\ndialect["from"] = "From the idea"\ndialect["global"] = "Using the global value for"\ndialect["if"] = "Supposing that"\ndialect["import"] = "Import the idea of"\ndialect["is"] = "Literally is"\ndialect["lambda"] = "Short instruction"\ndialect["not"] = "not"\ndialect["or"] = "or"\ndialect["pass"] = "Don\'t worry about it"\ndialect["print"] = "Print to console"\ndialect["raise"] = "Stop because there might be a problem"\ndialect["return"] = "The result is"\ndialect["try"] = "This might not work"\ndialect["while"] = "While"\ndialect["with"] = "In a new context, with"\ndialect["yield"] = "Remember this context for later, lets work on"\n#dialect["#"] = "Sidenote:" # does not work\ndialect["="] = "="\ndialect["!="] = "does not equal"\ndialect[":"] = ":"\ndialect[">="] = "is greater then or equal to"\ndialect[">="] = "is less then or equal to"\ndialect["=="] = "is equal to"\n\nverbose_dialect = dialectlibrary.Dialect(**dialect)\n'
tp59
asVsite
p60
(lp61
sVaudio
p62
(lp63
(Valsaaudiodevices.py
S'import time\nimport wave\n\n# install requires python-dev and libasound2:\n# sudo apt-get install python-dev\n# sudo apt-get install libasound2\n# sudo pip install pyalsaaudio\nimport alsaaudio\n\nimport mpre.base as base\nimport defaults\n\nclass Audio_Device(base.Base):\n\n    possible_options = ("rate", "channels", "format", "sample_size", "period", "type", "card")\n    def _get_options(self):\n        options = {}\n        for option in self.possible_options:\n            value = getattr(self, option, None)\n            if value:\n                options[option] = value\n        return options\n    options = property(_get_options)\n\n    def _get_full_buffer_size(self):\n        return self.channels * self.period_size * (self.sample_size / 8)\n    full_buffer_size = property(_get_full_buffer_size)\n\n    defaults = defaults.AlsaAudio_Device\n\n    def __init__(self, **kwargs):\n        self.listeners = []\n        super(Audio_Device, self).__init__(**kwargs)\n        print "%s %s initializing" % (self.name, self.card)\n        self.pcm = alsaaudio.PCM(type=self.type, mode=self.mode, card=self.card)\n        self.pcm.setchannels(self.channels)\n        self.pcm.setrate(self.rate)\n        self.pcm.setformat(self.format)\n        self.sample_size = self.sample_size\n        self.pcm.setperiodsize(self.period_size)\n\n        self.thread = self._new_thread()\n\n    def get_data(self):\n        raise NotImplementedError\n\n    def handle_data(self, audio_data):\n        for client in self.listeners:\n            self.rpc(client, audio_data)\n\n\nclass Audio_Input(Audio_Device):\n\n    defaults = defaults.AlsaAudio_Input\n\n    def __init__(self, **kwargs):\n        super(Audio_Input, self).__init__(**kwargs)\n\n    def get_data(self):\n        return next(self.thread)\n\n    def _new_thread(self):\n        pcm_read = self.pcm.read\n        data_source = getattr(self, "data_source", None)\n        read_data = getattr(data_source, "read", None)\n        \n        byte_scalar = self.sample_size / 8\n        handle_data = self.handle_data\n\n        while True:\n            frame_count, data = pcm_read()\n            if data_source:\n                byte_range = frame_count * byte_scalar\n                data = read_data(byte_range)\n            yield handle_data(data)\n\n\nclass Audio_Output(Audio_Device):\n\n    defaults = defaults.AlsaAudio_Output\n\n    def __init__(self, **kwargs):\n        super(Audio_Output, self).__init__(**kwargs)\n        if not self.data_source:\n            self.mute = True\n        else:\n            try:\n                self.data_source.listeners.append(self.instance_name)\n            except AttributeError:\n                self.input_from = self.data_source.read\n                \n    def _new_thread(self):\n        data_source = getattr(self, "data_source", self.pcm)\n        read_data = self.data_source.read\n        period_size = self.period_size\n        full_buffer_size = self.full_buffer_size\n        silence = "\\x00" * period_size\n        pcm_write = self.pcm.write\n\n        if self.input_from == self.data_source.read:\n            read_data = partial(self.data_source.read, full_buffer_size)\n        else:\n            read_data = lambda: \'\'.join(self.read_messages())\n        \n        data = \'\'\n        while True:\n            data += read_data()            \n            buffer_size = len(data)\n            if buffer_size >= full_buffer_size:\n                if self.mute:\n                    data = silence\n                pcm_write(data[:full_buffer_size])\n                data = data[full_buffer_size:]\n            yield\n\n    def get_data(self):\n        return next(self.thread)\n'
tp64
a(Vaudiolibrary.py
S'import array\nimport pickle\nimport struct\nimport wave\nimport sys\nimport atexit\n\nimport mpre.base as base\nimport mpre.vmlibrary as vmlibrary\nimport defaults\nfrom mpre.utilities import Latency\nInstruction = base.Instruction\n\n# supports both pyalsaaudio (linux) and pyaudio (cross platform)\nif "linux" in sys.platform:\n    import alsaaudiodevices as audio_devices\n    alsaaudio = audio_devices.alsaaudio\n    default_input, default_output = "hw:0,0", "hw:0,0"\n    DEVICES = dict((index, {"card" : "hw:{0},0".format(index), "name" : device_name}) for index,  device_name in enumerate(alsaaudio.cards()))    \n    default_input = DEVICES[0]\n    default_output = DEVICES[0]\n    \nelse:\n    import portaudiodevices as audio_devices\n    pyaudio = audio_devices.pyaudio\n    PORTAUDIO = audio_devices.PORTAUDIO\n    \n    host_api_info = PORTAUDIO.get_default_host_api_info()\n    input_index = host_api_info["defaultInputDevice"]\n    output_index = host_api_info["defaultOutputDevice"]\n    \n    default_input = PORTAUDIO.get_device_info_by_index(input_index)\n    default_output = PORTAUDIO.get_device_info_by_index(output_index)\n    \n    default_input["input_device_index"] = input_index\n    default_input["rate"] = int(default_input["defaultSampleRate"])\n    default_input["channels"] = default_input["maxInputChannels"]\n        \n    default_output["output_device_index"] = output_index\n    default_output["rate"] = int(default_input["defaultSampleRate"])\n    default_output["channels"] = default_input["maxInputChannels"]\n    \n    DEVICES = {}\n    for device_number in xrange(PORTAUDIO.get_device_count()):\n        device_info = PORTAUDIO.get_device_info_by_index(device_number)\n        options = {"channels" : max(device_info["maxOutputChannels"], device_info["maxInputChannels"]),\n                   "rate" : int(device_info["defaultSampleRate"]),\n                   "name" : device_info["name"]}\n        DEVICES[device_number] = options        \n\nAudio_Device = audio_devices.Audio_Device\nAudio_Input = audio_devices.Audio_Input\nAudio_Output = audio_devices.Audio_Output\n\ntry:\n    _Microphone = Audio_Input(**default_input)\n    _Speakers = Audio_Output(**default_output)\nexcept:\n    pass\n\nclass Wav_File(base.Base):\n\n    defaults = defaults.Wav_File\n\n    def _get_audiosize(self):\n        return self.channels * self.sample_width * self.file.getnframes()\n    audio_size = property(_get_audiosize)\n    \n    def __init__(self, **kwargs):\n        super(Wav_File, self).__init__(**kwargs)\n        \n        _file = self.file = wave.open(self.filename, self.mode)\n        if \'r\' in self.mode:\n            channels, sample_width, rate, number_of_frames, comptype, compname = self.file.getparams()\n                \n            self.channels = channels\n            self.sample_width = sample_width\n            self.format = 2 # hardcoded to PCM_FORMAT_S16_LE for quick fix\n            self.rate = rate\n            self.number_of_frames = number_of_frames\n            self.comptype = comptype\n            self.compname = compname\n        else:\n            _file.setparams((self.channels, self.sample_width, self.rate, 0, \'NONE\', \'not compressed\'))\n            \n        message = "opened wav file with channels: {0}, format: {1}, rate: {2}"\n        self.alert(message, (self.channels, self.sample_width, self.rate), level="vv")\n\n    def read(self, size=0):\n        size = size if size else self.audio_size\n        \n        data = self.file.readframes(size)\n        if self.repeat and (self.file.tell() == self.number_of_frames):\n            raise NotImplementedError\n       #     self.file.rewind()\n        return data\n\n    def tell(self):\n        return self.file.tell()\n\n    def write(self, data):\n        self.file.writeframes(data)\n\n    def close(self):\n        self.file.close()\n\n\nclass Audio_Configuration_Utility(vmlibrary.Process):\n\n    defaults = defaults.Audio_Configuration_Utility\n\n    def __init__(self, **kwargs):\n        self.selected_devices = []\n        super(Audio_Configuration_Utility, self).__init__(**kwargs)\n\n        if "default" in self.mode:\n            self.selected_devices.append(default_input)\n            self.selected_devices.append(default_output)\n            self.write_config_file(self.selected_devices)\n            self.delete()\n        else:\n            self.run_instruction.execute()\n\n    def write_config_file(self, device_list):\n        with open(self.config_file_name, "wb") as config_file:\n            for device in device_list:\n                print device\n            pickle.dump(device_list, config_file)\n            config_file.flush()\n            config_file.close()\n\n    def print_display_devices(self, device_dict):\n        for key, value in device_dict.items():\n            print "%s: %s" % (key, value)\n\n    def get_selections(self):\n        selection = ""\n        self.selected_devices = []\n\n        while "done" not in selection:\n            print "\\n"*80\n            print "type \'done\' to finish selecting..."\n            print "**************************************"\n            self.print_display_devices(DEVICES)\n            print "currently using: ", [str(item) for item in self.selected_devices]\n            selection = raw_input("Enter index of input device to use: ")\n            try:\n                index = int(selection)\n            except ValueError:\n                if selection == "done":\n                    break\n                else:\n                    raw_input("Invalid index. Press enter to continue...")\n            else:\n                try:\n                    device = DEVICES[index]\n                except KeyError:\n                    selection = raw_input("Invalid index. press enter to continue to or \'done\' to finish")\n                    if \'done\' in selection:\n                        break\n                else:\n                    name = raw_input("Rename device or press enter for default name: ")\n                    if name:\n                        device["name"] = name\n                                   \n                    self.selected_devices.append(device)\n        print "finished selecting devices"\n                                    \n    def run(self):\n        self.get_selections()\n        self.write_config_file(self.selected_devices)\n        self.delete()\n        if getattr(self, "exit_when_finished", None):\n            exit()\n\n\nclass Audio_Manager(vmlibrary.Process):\n\n    defaults = defaults.Audio_Manager\n\n    def _get_devices(self):\n        return self.objects.get("Audio_Input", []) + self.objects.get("Audio_Output", [])\n\n    audio_devices = property(_get_devices)\n\n    def __init__(self, **kwargs):\n        device_names = self.device_names = {}\n        super(Audio_Manager, self).__init__(**kwargs)\n                \n        if self.use_defaults:\n            self.load_default_devices()\n            \n        if self.config_file_name:\n            try:\n                self.load_config_file()\n            except IOError:\n                response = raw_input("No audio config file found\\nlaunch Audio_Config_Utility?: (y/n) ").lower()\n                if \'y\' in response:\n                    Instruction("System", "create", Audio_Configuration_Utility,        \n                                exit_when_finished=False).execute\n\n    def load_default_devices(self):\n        input = self.create(Audio_Input, **default_input)\n        output = self.create(Audio_Output, **default_output)\n        \n        self.device_names[input.instance_name] = input\n        self.device_names[output.instance_name] = output\n        \n    def load_config_file(self):\n        with open(self.config_file_name, "rb") as config_file:\n            for device_info in pickle.load(config_file):\n                device = self.create(Audio_Input, **device_info)\n                self.device_names[device.instance_name] = device\n                self.device_names[device.name] = device\n                \n    def send_channel_info(self, listener):\n        """usage: Instruction("Audio_Manager", "send_channel_info", my_object).execute()\n        => Message: "Device_Info;;" + pickled list containing dictionaries\n\n        Request a listing of available audio channels to the specified instances\n        memory. This message can be retrieved via instance.read_messages()"""\n        channel_info = []\n        for device in self.audio_devices:\n            options = dict(**device.options)\n            options["name"] = device.name\n            options["device_name"] = device.instance_name\n            options["sample_size"] = device.sample_size\n            channel_info.append(options)\n        channel_list = pickle.dumps(channel_info)\n        self.rpc(listener.instance_name, "Channel_Info;;" + channel_list)\n\n    def add_listener(self, listener, device_name):\n        return self.device_names[device_name].listeners.append(listener.instance_name)\n\n    def run(self):\n        for device in self.audio_devices:\n            device.get_data()\n        self.run_instruction.execute()\n\n    def play_file(self, file_info, file, to=None, mute=False):\n        _format = file_info["format"] # in bytes, pyaudio needs it\'s own constant instead\n        try:\n            format_name = PORTAUDIO.format_mapping[_format]\n            constant = getattr(pyaudio, format_name)\n            _format = constant\n            sample_size = int(format_name[-2:])\n        except NameError:\n            pass\n        options = {"data_source" : file,\n                   "mute" : mute,\n                   "format" : _format,\n                   "rate" : file_info["rate"],\n                   "channels" : file_info["channels"],\n                   "name" : file_info["name"]}\n        \n        speaker = self.create(Audio_Output, **options)\n        \n        if to:\n            speaker.listeners.append(to.instance_name)\n\n    def record(self, device_name, file, channels=2, rate=48000):\n        device = self.device_names[device_name]\n        \n        recording = self.create(Audio_Output, data_source=device,\n                                              name="{}_recording".format(device_name),\n                                              file=file, \n                                              channels=channels,\n                                              rate=rate)\n\n\nclass Audio_Channel(vmlibrary.Thread):\n\n    defaults = defaults.Audio_Channel\n\n    def __init__(self, **kwargs):\n        super(Audio_Channel, self).__init__(**kwargs)\n        self.frame = self._new_thread()\n\n    def run(self):\n        return next(self.frame)\n\n    def _new_thread(self):\n        read_messages = self.read_messages\n        join = \'\'.join\n        while True:\n            messages = read_messages()\n            if messages:\n                self.audio_data = join(messages)\n            yield\n\n    def read(self, bytes=0):\n        if not bytes:\n            bytes = len(self.audio_data)\n        data = self.audio_data[:bytes]\n        self.audio_data[bytes:]\n        return data\n\n\nclass Audio_Service(vmlibrary.Thread):\n\n    defaults = defaults.Audio_Service\n\n    def _get_channels(self):\n        return self.objects["Audio_Channel"]\n    channels = property(_get_channels)\n\n    def __init__(self, **kwargs):\n        self.channel_configuration = {}\n        self.audio_data = {}\n        self.clients_listening_to = {}\n        self.input_channels = {}\n        super(Audio_Service, self).__init__(**kwargs)\n        self.network_buffer = {}\n        self.objects["Audio_Channel"] = []\n        self.frame = self._new_thread()\n        Instruction("Audio_Manager", "send_channel_info", self).execute()\n\n    def run(self):\n        return next(self.frame)\n\n    def _new_thread(self):\n        messages = None\n        channels = self.objects["Audio_Channel"]\n\n        while not messages:\n            messages = self.read_messages()\n            yield\n\n        for message in messages:\n            header, message = message.split(";;")\n            channel_configuration = pickle.loads(message)\n            for channel_info in channel_configuration:\n                name = channel_info["name"]\n                device_name = channel_info["device_name"]\n                channel_info["latency"] = Latency(name=name)\n                channel = self.create(Audio_Channel, **channel_info)\n                Instruction("Audio_Manager", "add_listener", channel, device_name).execute()\n        yield\n\n        while True:\n            for channel in channels:\n                channel.run()\n            yield\n'
tp65
a(Vaudio_config_utility.py
S'#  Metapython.audio_config_utility - create config file for audiolibrary.audio_manager\n\nimport mpre.base as base\nInstruction = base.Instruction\n\ndef metapython_main():\n    Instruction("System", "create", "mpre.audio.audiolibrary.Audio_Configuration_Utility",            exit_when_finished=True).execute()   \nif __name__ == "__main__":\n    metapython_main()'
tp66
a(Vcapture_live_audio.py
S'#   mpf.capture_live_audio - records a .wav from the microphone\n#\n#    Copyright (C) 2014  Ella Rose\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport mpre.base as base\nBase = base.Base\nInstruction = base.Instruction\n\nimport audiolibrary\n\ndef metapython_main():\n    constructor = Base()\n    Instruction("System", "create", audiolibrary.Audio_Manager).execute()\n\n    print "creating wav file with two channels"\n    wav_file = constructor.create(audiolibrary.Wav_File, channels=2, rate=48000, filename="captured_live_audio.wav", mode=\'wb\')\n\n    Instruction("Audio_Manager", "record", "microphone", wav_file).execute()\n    \nif __name__ == "__main__":\n    metapython_main()'
tp67
a(Vdefaults.py
S'import mpre.defaults as defaults\nBase = defaults.Base\nProcess = defaults.Process\nThread = defaults.Thread\n\n# audiolibrary\n\nWav_File = Base.copy()\nWav_File.update({"mode" : "rb",\n"filename" : "",\n"repeat" : False,\n"channels" : 2,\n"rate" : 48000,\n"sample_width" : 2})\n\nAlsaAudio_Device = Base.copy()\nAlsaAudio_Device.update({"channels" : 1,\n"rate" : 48000,\n"format" : 2, # alsaaudio.PCM_FORMAT_S16_LE\n"sample_size" : 16,\n"period_size" : 1024,\n"card" : "hw:0,0",\n"data" : \'\',\n"frame_count" : 0,\n"mute" : False})\n\nAlsaAudio_Input = AlsaAudio_Device.copy()\nAlsaAudio_Input.update({"type" : 1, # PCM_CAPTURE\n"mode" : 1, # PCM_NONBLOCK\n"_data" : \'\'})\n\nAlsaAudio_Output = AlsaAudio_Device.copy()\nAlsaAudio_Output.update({"type" : 0, # PCM_PLAYBACK\n"mode" : 1}) # PCM_NONBLOCK\n\nPyAudio_Device = Thread.copy()\nPyAudio_Device.update({"format" : 8,\n"frames_per_buffer" : 1024,\n"data" : "",\n"record_to_disk" : False,\n"frame_count" : 0,\n"memory_size" : 65535})\n\nAudio_Input = PyAudio_Device.copy()\nAudio_Input.update({"input" : True,\n"_data" : \'\'})\n\nAudio_Output = PyAudio_Device.copy()\nAudio_Output.update({"output" : True,\n"mute" : False,\n"data_source" : None})\n\nAudio_Configuration_Utility = Process.copy()\nAudio_Configuration_Utility.update({"config_file_name" : "audiocfg",\n"mode" : ("input",),\n"auto_start" : False})\n\nAudio_Manager = Process.copy()\nAudio_Manager.update({"config_file_name" : \'audiocfg\',\n"use_defaults" : True,\n"priority" : .01})\n\nAudio_Channel = Thread.copy()\nAudio_Channel.update({"audio_data" : \'\',\n"memory_size" : 65535})\n\nAudio_Service = Thread.copy()\nAudio_Service.update({"memory_size" : 65535})\n\nVoip_Messenger = Process.copy()\nVoip_Messenger.update({"microphone_name" : "microphone",\n"port" : 40100,\n"name" : "voip_messenger",\n"channels" : 2,\n"rate" : 48000,\n"format" : 2,\n"message_header" : "message",\n"call_header" : "call",\n"hangup_header" : "hangup",\n"audio_header" : "audio"})'
tp68
a(Vplay_wav_file.py
S'#   mpf.play_wav_file - play a .wav file from disk\n\nimport sys\n\nimport mpre.base as base\nimport audiolibrary\nInstruction = base.Instruction\n\ndef metapython_main():\n    constructor = base.Base()\n    try:\n        filename = sys.argv[2]\n    except IndexError:\n        filename = "testrecording.wav"\n    wav_file = constructor.create(audiolibrary.Wav_File, filename=filename, mode=\'rb\')\n    info = {"rate" : wav_file.rate, "channels" : wav_file.channels, "name" : filename, "format" : wav_file.format}\n    \n\n    Instruction("System", "create", audiolibrary.Audio_Manager).execute()\n    Instruction("Audio_Manager", "play_file", info, wav_file).execute()\n\nif __name__ == "__main__":\n    metapython_main()'
tp69
a(Vportaudiodevices.py
S'# pyaudio requires: libportaudio0, libportaudio2, libportaudiocpp0, and portaudio19-dev on linux\n# linux installation instructions:\n# if installation was already attempted, do: sudo apt-get remove python-pyaudio\n# wget http://people.csail.mit.edu/hubert/pyaudio/packages/python-pyaudio_0.2.8-1_i386.deb\n# sudo dpkg -i python-pyaudio_0.2.8-1_i386.deb\nimport wave\nimport sys\nfrom contextlib import contextmanager\nfrom ctypes import *\nimport pyaudio\n\nimport mpre.base as base\nimport mpre.vmlibrary as vmlibrary\nfrom mpre.utilities import Latency\nimport defaults\nInstruction = base.Instruction\n\nFormatError = type("FormatError", (BaseException, ), {})\n\n@contextmanager\ndef _alsa_errors_suppressed():\n    prototype = CFUNCTYPE(None, c_char_p, c_int, c_char_p, c_int, c_char_p)\n    def do_nothing(filename, line, function, error, format):\n        return\n    c_suppression_function = prototype(do_nothing)\n    try:\n        alsa = cdll.LoadLibrary("libasound.so")\n    except OSError:\n        alsa = cdll.LoadLibrary("libasound.so.2")\n    alsa.snd_lib_error_set_handler(c_suppression_function)\n    yield\n    alsa.snd_lib_error_set_handler(None)\n\ndef _initialize_portaudio():\n    print "initializing PortAudio..."\n    if "linux" in sys.platform:\n        print "Trying to suppress ALSA configuration errors..."\n        with _alsa_errors_suppressed():\n            portaudio = pyaudio.PyAudio()\n        print "**Please ignore any warnings you may have received**"\n    else:\n        portaudio = pyaudio.PyAudio()\n    print "...done"\n    return portaudio\n\nPORTAUDIO = _initialize_portaudio()\n\nPORTAUDIO.format_mapping = {1 : "paInt8",\n                            2 : "paInt16",\n                            3 : "paInt24",\n                            4 : "paInt32"}\n                            \ndef _formats_to_indices():\n    format_lookup = {}\n    for device_index in range(PORTAUDIO.get_device_count()):\n        device_info = PORTAUDIO.get_device_info_by_index(device_index)\n        rate = device_info["defaultSampleRate"]\n        \n        channels = device_info["maxInputChannels"]\n        if channels:\n            in_or_out = "input"\n        else:\n            channels = device_info["maxOutputChannels"]\n            in_or_out = "output"\n        \n        try:\n            format_lookup[(rate, channels, in_or_out)].append(device_info["index"])\n        except KeyError:\n            format_lookup[(rate, channels, in_or_out)] = [device_info["index"]]\n    return format_lookup\n    \nformat_lookup = _formats_to_indices()\n           \nclass Audio_Device(vmlibrary.Thread):\n\n    defaults = defaults.PyAudio_Device\n    possible_options = ("rate", "channels", "format", "input", "output", "input_device_index",\n    "output_device_index", "frames_per_buffer", "start", "input_host_api_specific_stream_info",\n    "output_host_api_specific_stream_info", "stream_callback")\n    # properties are calculated attributes\n    def _get_options(self):\n        options = {}\n        for option in self.possible_options:\n            value = getattr(self, option, None)\n            if value:\n                options[option] = value\n        \n        return options\n    options = property(_get_options)\n\n    def _get_full_buffer_size(self):\n        return self.channels * self.frames_per_buffer * self.sample_size\n    full_buffer_size = property(_get_full_buffer_size)\n\n    def __init__(self, **kwargs):\n        self.listeners = []\n        self._format_error = "{}hz {} channel {} not supported by any api"\n        self.sample_size = PORTAUDIO.get_sample_size(pyaudio.paInt16)\n        super(Audio_Device, self).__init__(**kwargs)\n        \n    def open_stream(self):\n        return PORTAUDIO.open(**self.options)\n        \n    def _new_thread(self):\n        raise NotImplementederror\n        \n    def get_data(self):\n        raise NotImplementedError\n\n    def handle_data(self, audio_data):\n        for client in self.listeners:\n            self.rpc(client, audio_data)\n        \n\nclass Audio_Input(Audio_Device):\n\n    defaults = defaults.Audio_Input\n\n    def __init__(self, **kwargs):\n        super(Audio_Input, self).__init__(**kwargs)\n        \n        if not hasattr(self, "input_device_index"):\n            try:\n                self.input_device_index = format_lookup[(self.rate, self.channels, "input")][0]\n            except KeyError:\n                raise FormatError(self._format_error.format(self.rate, self.channels, "input"))\n       \n        self.thread = self._new_thread()\n        \n    def read(self, size=0):\n        byte_count = len(self._data)\n        size = size if size else byte_count\n        \n        if size <= byte_count:\n            result = self._data[:size]\n        else:\n            print "not enough bytes for request {} ({} available)".format(size, byte_count)\n            result = 0\n        return result\n        \n    def _new_thread(self):\n        stream = self.open_stream()\n        get_read_available = stream.get_read_available\n        read_stream = stream.read\n\n        data_source = getattr(self, "data_source", stream)\n        data_read = getattr(data_source, "read")\n        handle_data = self.handle_data\n\n        if data_source is not stream:\n            byte_scalar = self.sample_size * self.channels\n        else:\n            byte_scalar = 1\n            \n        frames_per_buffer = self.frames_per_buffer\n        full_buffer_size = self.full_buffer_size\n        frame_counter = self.frame_count\n        _data = \'\'\n\n        while True:\n            frame_count = get_read_available()\n            data = read_stream(frame_count * byte_scalar)\n            _data += data\n            frame_counter += frame_count\n            \n            if frame_counter >= frames_per_buffer:\n                frame_counter -= frames_per_buffer\n                handle_data(_data[:full_buffer_size])\n                self._data = _data = _data[full_buffer_size:]\n            yield\n\n    def get_data(self):\n        return next(self.thread)\n\n\nclass Audio_Output(Audio_Device):\n\n    defaults = defaults.Audio_Output\n\n    def __init__(self, **kwargs):\n        super(Audio_Output, self).__init__(**kwargs)\n        \n        if not hasattr(self, "output_device_index"):\n            try:\n                self.output_device_index = format_lookup[(self.rate, self.channels, "output")][0]\n            except KeyError:\n                raise FormatError(self._format_error.format(self.rate, self.channels, "output"))\n        \n        self.input_from = self.read_messages \n        if not self.data_source:\n            self.mute = True    \n        else:\n            try:\n                self.data_source.listeners.append(self.instance_name)\n            except AttributeError:\n                self.input_from = self.data_source.read\n                \n        self.thread = self._new_thread()\n                \n    def _new_thread(self):\n        stream = self.open_stream()\n        destination = getattr(self, "file", stream)\n        stream_write = destination.write\n        get_write_available = stream.get_write_available\n\n        if destination != stream:\n            byte_scalar = self.sample_size * self.channels\n        else:\n            byte_scalar = 1\n                \n        frames_per_buffer = self.frames_per_buffer\n        full_write_buffer = byte_scalar * frames_per_buffer\n        silence = "\\x00" * full_write_buffer\n\n        read_source = self.input_from\n        handle_data = self.handle_data\n        \n        format_mismatch = "format mismatch. expected {} bytes, got {} bytes"\n                                \n        while True:\n            number_of_frames = get_write_available()\n            if number_of_frames >= frames_per_buffer:               \n                data_packet = read_source()\n                if not data_packet:\n                    yield\n                    continue\n                             \n                data = silence if self.mute else \'\'.join(data_packet)\n                \n                # rpc listeners here\n                handle_data(data)\n                # write to device/file here\n                stream_write(data)\n                \n            yield\n\n    def get_data(self):\n        return next(self.thread)\n'
tp70
a(Vvoipmessenger.py
S'#   mpf.voip_messenger - send and receive text and audio\n#\n#    Copyright (C) 2014  Ella Rose\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU General Public License as published by\n#    the Free Software Foundation, either version 3 of the License, or\n#    (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU General Public License for more details.\n#\n#    You should have received a copy of the GNU General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport mpre.base as base\nimport mpre.vmlibrary as vmlibrary\nimport audiolibrary\nimport defaults\nInstruction = base.Instruction\n\nclass Voip_Messenger(vmlibrary.Process):\n\n    defaults = defaults.Voip_Messenger\n\n    def __init__(self, **kwargs):\n        self.log = {}\n        self.listeners = []\n        self.talking_to = {}\n        super(Voip_Messenger, self).__init__(**kwargs)\n        self.network_buffer = {}\n        \n        self.keyboard = self.create("metapython.core.keyboard.Keyboard")\n        self.audio_service = self.create(audiolibrary.Audio_Service)\n\n        file_info = {"format" : self.format,\n                     "rate" : self.rate,\n                     "channels" : self.channels,\n                     "name" : self.name}\n        Instruction("Audio_Manager", "play_file", file_info, self.file).execute()\n        options = {"port" : self.port,\n                   "socket_recv" : self._socket_recv,\n                   "socket_send" : self._socket_send}\n        self.socket = self.create("network.Udp_Socket", **options)\n        \n    def _socket_recv(self, connection):\n        data, _from = connection.recvfrom(self.network_packet_size)\n        self.network_buffer[(connection, _from)] = data\n\n    def _socket_send(self, connection, data):\n        to, data = data\n        connection.sendto(data, to)\n\n    def run(self):\n        self.audio_service.run()\n        self.send_audio()\n        try:\n            self.handle_input()\n        except (AttributeError, ValueError):\n            print "Commands: message, call, hangup"\n            print "to send a message: message address:port this is the message"\n            print "to call: call address:port"\n            print "to hangup: hangup address:port"\n        self.handle_socket_recv()\n\n        self.run_instruction.execute()\n\n    def send_audio(self):\n        for channel in self.audio_service.objects["Audio_Channel"]:\n            data = channel.read()\n            if self.microphone_name in channel.name and data:\n                for listener in self.listeners:\n                    args = (self.socket, channel.audio_data, listener)\n                    self.socket.rpc(listener, channel.audio_data)\n                    \n            channel.audio_data = \'\'\n\n    def handle_input(self):\n        if self.keyboard.input_waiting():\n            self.keyboard.get_line(self)\n\n        if self.keyboard_input:\n            input = self.keyboard_input\n            self.keyboard_input = \'\'\n            command, argument = input.split(" ", 1)\n            if command == "message":\n                address, message = argument.split(\' \', 1)\n                message = self.message_header + message\n            else:\n                address = argument\n                message = getattr(self, "%s_header" % command)\n            ip, port = address.split(":")\n            to = (ip, int(port))\n            self.socket.rpc(to, message)\n\n    def handle_socket_recv(self):\n        for _from, data in self.network_buffer.items():\n            header, message = data.split(" ", 1)\n            if "call" in header:\n                if "y" in raw_input("Call from %s; accept? y/n: " % _from).lower():\n                    self.calls.apend(_from)\n            elif "hangup" in header:\n                try:\n                    self.calls.remove(_from)\n                except ValueError:\n                    pass\n            elif "audio" in header and _from in self.listening_to:\n                self.file.seek(0)\n                self.file.write(message)\n                self.file.seek(0)\n            elif "message" in header:\n                try:\n                    self.log[_from].write(message + "\\n")\n                except KeyError:\n                    self.log = {_from : open("%s.log" % _from, "a")}\n                    self.log[_from].write(message + "\\n")\n                print "%s: %s" % (self.talking_to[_from], message)\n\ndef metapython_main():    \n    Instruction("System", "create", audiolibrary.Audio_Manager).execute()\n    Instruction("System", "create", Voip_Messenger).execute()\n    \nif __name__ == "__main__":\n    metapython_main()'
tp71
assS'file_source'
p72
(dp73
sS'make_docs'
p74
I01
sS'package_name'
p75
Vmpre
p76
sS'store_source'
p77
I01
sS'deleted'
p78
I00
sS'verbosity'
p79
Vvvv
p80
sS'instance_name'
p81
S'Package'
p82
sS'_return_to'
p83
(dp84
sS'objects'
p85
(dp86
S'Documentation'
p87
(lp88
g1
(cmpre.package
Documentation
p89
g3
NtRp90
(dp91
S'network_packet_size'
p92
I4096
sg81
g87
sS'site_name'
p93
g76
sS'package'
p94
g4
sg78
I00
sg79
S'vv'
p95
sS'ignore_directories'
p96
(S'docs'
tp97
sS'instance_number'
p98
I0
sg83
(dp99
sg85
(dp100
sS'memory_size'
p101
I4096
sS'ignore_files'
p102
(S'build_documentation.py'
tp103
sS'subfolders'
p104
(tsS'directory'
p105
VC:\u005cusers\u005c_\u005cpythonbs\u005cmpre
p106
sS'index_page'
p107
(lp108
S'index.md'
p109
aS'Homepage'
p110
asbassg101
I4096
sg104
(lp111
Vprograms
p112
aVaudio
p113
aVgui
p114
aVmisc
p115
asg105
VC:\u005cusers\u005c_\u005cpythonbs
p116
sg92
I4096
sg98
I0
sb.