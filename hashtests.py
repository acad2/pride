import itertools
import random

from pride.decorators import Timed
from pride.datastructures import Average

ASCII = ''.join(chr(x) for x in range(256))

def binary_form(_string):
    """ Returns the a string representation of the binary bits that constitute _string. """
    try:
        return ''.join(format(ord(character), 'b').zfill(8) for character in _string)
    except TypeError:        
        bits = format(_string, 'b')
        bit_length = len(bits)
        if bit_length % 8:
            bits = bits.zfill(bit_length + (8 - (bit_length % 8)))                
        return bits
        
def byte_form(bitstring):
    """ Returns the ascii equivalent string of a string of bits. """
    try:
        _hex = hex(int(bitstring, 2))[2:]
    except TypeError:
        _hex = hex(bitstring)[2:]
        bitstring = binary_form(bitstring)
    try:
        output = binascii.unhexlify(_hex[:-1 if _hex[-1] == 'L' else None])
    except TypeError:
        output = binascii.unhexlify('0' + _hex[:-1 if _hex[-1] == 'L' else None])
        
    if len(output) == len(bitstring) / 8:
        return output
    else:
        return ''.join(chr(int(bits, 2)) for bits in slide(bitstring, 8))
        
_type_resolver = {"bytes" : byte_form, "binary" : binary_form, "int" : lambda bits: int(bits, 2)}
    
def cast(input_data, _type):
    return _type_resolver[_type](input_data)
    
def hamming_distance(input_one, input_two):
    size = len(input_one)
    if len(input_two) != size:
        raise ValueError("Inputs must be same length")
    count = 0
    for index, bit in enumerate(input_one):
        if input_two[index] == bit:
            count += 1
    return count
    #return format(int(input_one, 2) ^ int(input_two, 2), 'b').zfill(size).count('1')   
         
def print_hamming_info(output1, output2):
    output1_binary = binary_form(output1)
    output2_binary = binary_form(output2)
    _distance = hamming_distance(binary_form(output1), binary_form(output2))
    bit_count = len(output1_binary)
    print "bit string length: ", bit_count
    print "Hamming weights: ", output1_binary.count('1'), output2_binary.count('1')
    print "Hamming distance and ratio (.5 is ideal): ", _distance, _distance / float(bit_count)
    
def test_avalanche(hash_function):        
    print "Testing diffusion and avalanche"
    output1 = hash_function("The quick brown fox jumps over the lazy dog" * 100)
    output2 = hash_function("The quick brown fox jumps over the lazy cog" * 100)    
    print_hamming_info(output1, output2)
    
def test_randomness(hash_function):    
    print "Testing randomness distribution of 1024 * 1024 psuedorandomly generated bytes... "
    random_bytes = hash_function('', output_size=1024 * 1024)
    outputs = dict((x, random_bytes.count(chr(x))) for x in xrange(256))
    average = Average(values=tuple(random_bytes.count(chr(x))for x in xrange(256)))
    print "Randomness distribution (min, average, max): (~4100 is good): ", average.range
    import pprint
    pprint.pprint(sorted(outputs.items()))
        
def test_hash_chain(hash_function, test_size=1):
    outputs = ['']
    output = ''   
    print "Testing hash chain period: "
    for cycle_length in itertools.count():
        output = hash_function(output)[:test_size]
        if output in outputs:
            print "Hash chain cycled after {} with {} byte output: ".format(cycle_length, test_size)
            break
        outputs.append(output)
                
def test_bias(hash_function, byte_range=slice(8)):
    biases = [[] for x in xrange(8)]    
    outputs2 = []    
    for x in xrange(256):
        output = hash_function(chr(x))
        for index, byte in enumerate(output[:8]):
            biases[index].append(ord(byte))
        outputs2.extend(output[byte_range])        
    print "Byte bias: ", [len(set(_list)) for _list in biases]   
    print "Symbols out of 256 that appeared anywhere: ", len(set(outputs2))
    
def test_collisions(hash_function, output_size=3):      
    outputs = {}        
    print "Testing for collisions with output of {} bytes... ".format(output_size)
    for count, possibility in enumerate(itertools.product(ASCII, ASCII)):
        hash_input = ''.join(possibility)        
        hash_output = hash_function(hash_input)[:output_size]
        if hash_output in outputs:
            print "Collision after: ", count, "; Output size: ", output_size
            break
        else:
            outputs[hash_output] = hash_input
    else:
        print "No collisions after {} inputs with output size {}".format(count, output_size), len(set(outputs))
    
def test_performance(hash_function):
    from pride.decorators import Timed
    print "Time testing compression function..."
    print Timed(hash_function, 100)("Timing test hash input" * 1000)
    
    print "Testing time to generate 1024 * 1024 bytes... "
    print Timed(hash_function, 1)('', output_size=1024 * 1024)
    
def test_hash_function(hash_function):
    test_avalanche(hash_function)
    test_randomness(hash_function)
    test_hash_chain(hash_function)    
    test_bias(hash_function)
    test_collisions(hash_function)
    test_performance(hash_function)
    