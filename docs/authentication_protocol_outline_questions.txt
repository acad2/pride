Upon registration, the server generates 256 random bytes and sends them to the client
These 256 bytes represent a 16 x 16 grid of random symbols
The server and client both remember this table and set their initial shared key to nulls
Registration must take place via secured or out of band communication
Registering a username is optional. No password registration is required by the server.

The login process is as follows:
    
- The table and shared key are read from persistent storage
- The current "session id" is calculated as the hash of table + shared key
- The client generates a challenge of N (x, y) coordinates, where x and y 
  range between 0 and 15. The combination indicates a particular symbol
  on the grid. The answer to the challenge is calculated, hashed with the 
  shared key, and stored, while the challenge is sent to the server.
- The server receives the session id and challenge, and generates a 
  challenge of it's own for the client.

- If the session id is valid, the server calculates and hashes the challenge
answer + shared key and returns the response with it's own challenge   
- If the session id is invalid, a random "response" to the clients
  challenge is generated and returned to the client with the servers challenge 
  
- If the client does not receive the correct response to it's challenge, login is aborted
- If the server response is correct, the challenge is answered and hashed with the shared key
  The hashed answer and servers challenge are returned to the server
  
- The server finds the session id, calculates the correct answer for the challenge,
  and matches the hashed answer + secret against the clients answer
  
- If the answers match, the client is authenticated
- a new random shared key is generated by the server and encrypted 
  with the old shared key (AES-GCM 16 byte random iv authenticated as extra data)
- A new table is calculated via hash of the old table with the new key. 
- Currently hkdf expand is used to derive the 256 bytes. 
- The new session id is calculated as the hash of the new table and the new key
- The encrypted key is returned to the client
- If the answers do not match or the session id is invalid, a random "encrypted key"
  is generated and returned to the client
  
- The client receives and decrypts the key, and calculates the new table and session id
  The new table and key are stored.
- If the login attempt was invalid, decryption will fail, most likely with InvalidTag from
  the data failing to authenticate.

Does the above scheme succeed in providing authenticity between client/server?

Assuming the answer to the above is not no, further questions are:

The client returning the challenge simplified the implementation server side with what needed
to be stored in the db; is having the client return the challenge detrimental to security?
  
All hashes except for table derivation are performed as sha256(input + ':' + shared key).
Is the input to the hash function always large enough to preclude brute force search?  

Is it possible/How would you begin to enumerate usernames in a system like this?
Is it possible/How would you begin to brute force admin credentials? 

Does the inclusion of random data in the form of the new key create "perfect forward secrecy"?
If not, can I have a simple example demonstrating how this goal is achieved?

Since the table becomes a key/token/"something you have", it is stored encrypted
on disk. Upon application startup a master key is derived from a password + 16 byte 
random salt, and an encryption key derived from that. When access to the table
is needed for login, the table is decrypted into memory only. Does this qualify
as "two factor authentication" despite the server not validating/having anything to
do with the clients password? The user of the client application only sees
entering a username/password; management of the table and answering of challenges is automated.
